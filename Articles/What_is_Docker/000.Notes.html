<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-03-22 Sat 23:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>What is Docker?</title>
<meta name="author" content="Alfredo Mejia" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../../resources/bulma/bulma.css" /> <style>body {margin: 5%} h1,h2,h3,h4,h5,h6 {margin-top: 3%}</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">What is Docker?</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0c74c44">Navigation</a></li>
<li><a href="#org1f1e155">What is Docker?</a>
<ul>
<li><a href="#org41d5b3d">History: Before VMs &amp; Containers</a>
<ul>
<li><a href="#orgcb0000a">One Server One Application</a></li>
<li><a href="#orgd80a58d">One Server Multiple Applications</a></li>
</ul>
</li>
<li><a href="#org15f6109">Virtual Machines</a>
<ul>
<li><a href="#orgc4a4042">How does VMs work?</a></li>
<li><a href="#orgace6f0c">What's the benefit of VMs</a></li>
<li><a href="#orgaa93e86">Drawbacks of VMs</a></li>
</ul>
</li>
<li><a href="#org286c030">Containerization</a>
<ul>
<li><a href="#org29952a2">How do containers work?</a></li>
<li><a href="#org49da2f8">Advantages of Containerization</a></li>
<li><a href="#org90ec966">Disadvantages of Containers</a></li>
</ul>
</li>
<li><a href="#org1bd4224">Docker</a></li>
</ul>
</li>
<li><a href="#org73c642d">Using Docker</a>
<ul>
<li><a href="#orgc1f21f0">Apache HTTP Server</a>
<ul>
<li><a href="#org0ac43cf">Clients, Servers, &amp; URLs</a></li>
<li><a href="#orge9d62e5">Hostnames &amp; DNS</a></li>
<li><a href="#orge177ba7">Configuration Files &amp; Directives</a></li>
<li><a href="#org5aa4589">Web Site Content</a></li>
<li><a href="#orgb6047e9">Log Files &amp; Troubleshooting</a></li>
<li><a href="#orgdcde349">Installing</a></li>
<li><a href="#orgbcb5b14">Configuring Apache</a></li>
<li><a href="#orgac120a8">Creating A Docker File &amp; Docker Image</a></li>
</ul>
</li>
<li><a href="#org5132346">Django</a>
<ul>
<li><a href="#org1fb79fe">Creating Django Project</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge892c91">Resources</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0c74c44" class="outline-2">
<h2 id="org0c74c44">Navigation</h2>
<div class="outline-text-2" id="text-org0c74c44">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Nav</th>
<th scope="col" class="org-left">Title</th>
<th scope="col" class="org-left">Links</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Index</td>
<td class="org-left">Notes Home</td>
<td class="org-left">&vert; <a href="../../index.html">html</a> &vert; <a href="../../index.html">org</a> &vert; <a href="https://github.com/alfredo-mejia/notes/tree/main">github</a> &vert;</td>
</tr>

<tr>
<td class="org-left">Home</td>
<td class="org-left">Articles</td>
<td class="org-left">&vert; <a href="../000.Home.html">html</a> &vert; <a href="../000.Home.html">org</a> &vert; <a href="https://github.com/alfredo-mejia/notes/tree/main/Articles">github</a> &vert;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org1f1e155" class="outline-2">
<h2 id="org1f1e155">What is Docker?</h2>
<div class="outline-text-2" id="text-org1f1e155">
</div>
<div id="outline-container-org41d5b3d" class="outline-3">
<h3 id="org41d5b3d">History: Before VMs &amp; Containers</h3>
<div class="outline-text-3" id="text-org41d5b3d">
<p>
One might ask the question, how did people deploy applications before VMs and containers? Before, people and companies would deploy their applications on a bare server.
This means companies would first have to order the server (hardware), then install an OS in the server, install any dependencies it needs, compile the source code of the application on the server, and run the application on the server.
These servers would be inside an on-premise data center.
Typically, only one application would run on one server. As operating systems advanced, companies would start to run multiple applications on one server relying heavily on the OS resource management, multi-tasking, and process isolation capabilities.
However, there are drawbacks to running multiple applications on one server and it was often done with specific configurations and considerations.
This is why it was more common to have one server dedicated to run that one application. For example, one server would be for web hosting, another server for the database, and another server for the email service.
Let's talk about the challenges of running an application on a bare server and why running multiple applications on one server would be considered a bad idea.
</p>
</div>

<div id="outline-container-orgcb0000a" class="outline-4">
<h4 id="orgcb0000a">One Server One Application</h4>
<div class="outline-text-4" id="text-orgcb0000a">
<p>
One server would be dedicated to running one application.
That sounds reasonable but what are the drawbacks? The first major drawback is that it is time-consuming.
For example, let's say you develop another application, this means you would have to order a server, buy a license for an OS, install any dependencies, compiling the source code, and finally running the source code. This takes time but new technologies emerged to easily setup and configure bare servers but this still was not enough.
</p>

<p>
The second major drawback was money.
A single application would not be able to fully use all of the server's resources so some resources will be left unused resulting in inefficiency and a waste of money.
Then scaling would be costly for single application running on a bare server.
Let's say you want to scale your application, you can upgrade the server's hardware but that will only take you so far with the performance and cost.
Another solution would be adding servers.
So then you would have order a new batch of servers, configure them, compile and run. This would cost a lot of money, and in addition, each application would be underutilizing the server's resources leading to a loss of money. 
You would also have to order servers for your development team to have a testing environment with the same dependencies and configurations as the prod environment.
Then if you were to upgrade your application, you would have to ensure it works on the prod environment and the configurations are consist throughout your servers.
This seems like a lot of work for something that is inefficient and costly.
</p>
</div>
</div>

<div id="outline-container-orgd80a58d" class="outline-4">
<h4 id="orgd80a58d">One Server Multiple Applications</h4>
<div class="outline-text-4" id="text-orgd80a58d">
<p>
One might assume it would just be smarter to run multiple applications on one server.
Although the idea would be the precursor to VMs and containers, there are many drawbacks to this idea as well.
One of the drawbacks is that most applications running in the same bare server relied on the OS resource management capabilites.
Up to this point, there were no way to allocate resources for each application and no resource isolation.
This means one application may consume all the resources while leaving the other application locked for contention causing the application to be slow or even crash.
In addition, without resource isolation each application could compete for resources but most importantly it was a security risk.
An application may be able to interfere with the other application's resources.
</p>

<p>
Another issue with running multiple applications in the same server are dependency conflicts.
One application may require a library with the newest version and the other application may require the same library with the older version.
These can lead to dependencies conflicts and errors.
</p>

<p>
As previously mentioned this could also pose a security risk. Since there is no resource isolation one application can maliciously affect all applications running.
It was harder to maintain and upgrade because let's say we want to upgrade application A with a new version of libraries but application B uses the old version of libraries.
This could lead to dependency conflicts as previously discussed.
</p>

<p>
Scalability becomes harder as well.
Scalability of a single application on a bare server is hard in itself due to the configurations but now imagine two applications with their configurations and own dependencies.
</p>

<p>
Finally, the last issue is fault tolerance.
If an application crashes and dies since there is no isolation between applications it could potentially affect the other applications running on the bare server.
Or if the actual hardware were to fail then all applications would come down.
So we need to scale horizontally to introduce fault tolerance and redundancy but with this setup it is difficult to do so.
This is where virtual machines (VMs) are introduced.
</p>
</div>
</div>
</div>

<div id="outline-container-org15f6109" class="outline-3">
<h3 id="org15f6109">Virtual Machines</h3>
<div class="outline-text-3" id="text-org15f6109">
<p>
According to <a href="https://www.redhat.com/en/topics/virtualization/what-is-a-virtual-machine">Red Hat</a> a VM "is a computing environment that functions as an isolated system with its own CPU, memory, network interface, and storage, created from a pool of hardware resources".
What does that mean? It means that a VM simulates a working operating system on top of some virtual hardware.
This means a VM has an OS working with a virtual CPU, virtual memory, virtual storage.
The virtual hardware shares physical hardware with other VMs.
The great thing about this is that as far as the OS and all applications running on the VM are concerned, they are utilizing physical hardware resources.
In addition, one server can hold multiple VMs and each VM is isolated and could be running a completely different OS than the other VMs.
</p>
</div>

<div id="outline-container-orgc4a4042" class="outline-4">
<h4 id="orgc4a4042">How does VMs work?</h4>
<div class="outline-text-4" id="text-orgc4a4042">
<p>
VMs run a OS through a simulation of hardware. This is taken care of by the hypervisor.
The hypervisor acts as the middle man between the VMs and the actual hardware.
The hypervisor is in charge whenever a VM is using some virtual resource it needs to allocate that resource to some actual physical resource.
There are two types of hypervisors: type 1 and type 2. Type 1 hypervisor runs on the bare server meaning it runs on the host's physical hardware. Type 1 hypervisor does not need an OS to run and can access the hardware directly. Type 2 hypervisor runs on top of an OS. It uses the OS access to the hardware to virtualize VMs. 
Type 1 is considered more secure and more efficient than type 2, but type 1 is harder to install and manage.
Each type of hypervisor has its pros and cons.
</p>
</div>
</div>

<div id="outline-container-orgace6f0c" class="outline-4">
<h4 id="orgace6f0c">What's the benefit of VMs</h4>
<div class="outline-text-4" id="text-orgace6f0c">
<p>
There are many benefits to using VMs. One of them is resource allocation and isolation.
Let's say you have 3 VMs in one server. Then you can allocate each VM a third of the physical hardware.
As far as the VMs are concerned, they can use 100% of the resource allocated to them without seizing resources of over VMs.
This is beneficial because before one application might need a lot of resources but this won't affect the other VMs to fight for contention because all resources have been allocated.
Another benefit is resource isolation. If a VM has been compromised or crashes, only the resources allocated to that VM will be affected.
The VMs will not be affected because each of their resources are isolated from one and another.
With resource allocation and resource isolation it provides efficiency use of the server because now all the servers resources are being used, each VM and their application it runs are secure, and thus you can run multiple applications in a single server efficiently and securely saving lots of money.
</p>

<p>
VMs are less time-consuming as well. With VMs, you can clone, snapshot, or make VM image to be able to quickly replicate the VM configurations. This is a time-saver because whenever you need to create another VM for application you can simply take your initial VM image and create a VM in the same server, in a different server, or in a developer's workstation.
The VM image will ensure it has the same configurations as your production environment.
Thus you can ensure there are less bugs, less dependencies conflicts, and ensure your developers are developing and testing in the same configured environment as the prod environment.
Plus VMs are easy to take snapshots and revert back to old versions.
So let's say we are going to update an application. We take a snapshot of the current VM's state.
Then we develop on our developer environment which should have the same configurations as the prod environment.
We develop a new VM image. This VM image can then be used on prod environments to ensure consistency throughout the developer environment all the way to the prod environment.
Now let's say something is wrong with the prod environment then with your VM snapshot you can revert back to the snapshot.
VMs save money and time compared to running an application on a bare server.
</p>
</div>
</div>

<div id="outline-container-orgaa93e86" class="outline-4">
<h4 id="orgaa93e86">Drawbacks of VMs</h4>
<div class="outline-text-4" id="text-orgaa93e86">
<p>
The biggest drawbacks of VMs are the heavy-load of resources.
Companies always wants more efficiency. VMs are great for resource allocation and resource isolation but is it the most efficient way to achieve that?
The answer is no.
</p>

<p>
Each VM needs an OS that means if you have 5 VMs running on a server then you will need 5 OSes installed on the computer even if your application running on the VM are lightweight.
That means your server will require lots of resources for those 5 VMs to run.
OSes are always heavy and bloated so having multiple running in the same server requires an extensive use of hardware resources.
This means if you wanted to add more VMs to your server you wouldn't be able to because VMs are heavy require a lot of CPU and a lot of disk space.
So you have to allocate a fair amount of resources for each VM so that each VM can run smoothly otherwise the VM will be slow or even crash.
Thus, if a company wants to put as much VMs into a single server then that company won't get too far because of how heavy each VM is.
</p>

<p>
Another issue with VMs is that they do not share unused resources. For example, let's say I have 3 VMs. Those 3 VMs have their allocated resources. Two of the VMs are basically idle and their resources are left unused.
The third VM is using 100% of its resources. Ideally it would be great if the 3rd VM used the unused resources of VMs 1 and 2. Then whenever VM 1 and VM 2 need their resources they pull it back from VM 3 and continue with their resource limit and isolation. Or what if we have resources that were not allocated to any VM. It would be great for all the VMs to use the resources as a on-need basis.
Thus VMs do not utilize resources as efficiently as it can be. If one VM is not using the their resources and another VM is then you are left with some resources being left unused. Because of that a company might need another server due reduce workload when if resources were utilized efficiently that would not need to be required. People and companies do not want that. They want to be the most efficient. They want to get most bang for their buck. So they want their computer and server to utilize all their resources efficiently. Although VMs allow for resource allocation and resource isolation, it is not the most efficient when deploying applications.
</p>

<p>
In the end, VMs have their pros and cons. VMs are great solutions in certain situations but for applications containers are often used when deploying applications.
</p>
</div>
</div>
</div>

<div id="outline-container-org286c030" class="outline-3">
<h3 id="org286c030">Containerization</h3>
<div class="outline-text-3" id="text-org286c030">
<p>
According to <a href="https://www.ibm.com/think/topics/containerization">IBM</a> "containzeration is the packaging of software code with just the operating system libraries and dependencies required to run the code to create a single lightweight executable called a container that runs consistently on any infrastructure".
This means a container is all the files, libraries, and executables for the application to run, without the OS.
It packages all the libaries and dependencies of the OS without the actual OS. This makes containers much more lightweight than VMs.
</p>
</div>

<div id="outline-container-org29952a2" class="outline-4">
<h4 id="org29952a2">How do containers work?</h4>
<div class="outline-text-4" id="text-org29952a2">
<p>
So containers are isolated environments. Containers package all you need to run such as the application code, dependencies, OS libraries, configurations files, and anything else into something called a container image.
The container image has all the information needed to create your application.
The container image knows your application code, all the configurations, libraries it uses, and dependencies it needs.
</p>

<p>
Each container only has what it needs but it does not have an operating system. It could contain the libraries of an OS like Ubuntu libraries but the actual OS is not present in a container making containers very lightweight.
</p>

<p>
So how does it run the application? It uses the host system's kernel. There may be multiple containers running on the same host thus all containers will share the system's kernel. This means we only have one operating system in our host system on which all containers run. Recall that the kernel is the core part of the OS that manages all the system resources. All Linux distros use the same "Linux" kernel with slight variations but many are the same. Containerization only uses the Linux kernel because the Linux kernel offers features like cgroups and namespaces to isolate groups of processes. 
</p>

<p>
What if we use an Ubuntu library in our container and the host system is Arch?
Well since our container is isolated from the host and other containers there will be no dependency conflicts.
In addition, the container will contain the Ubuntu library and any dependencies it has.
Thus, this library will then make systems calls using the Arch's kernel.
Since Ubuntu and Arch use the same Linux kernel the system calls made by Ubuntu's libraries should be able to use the host's kernel and thus be able to run and execute their code.
</p>

<p>
This is why containerzation tools like Docker does not work natively on Mac or Windows.
This is because containerzation was built on Linux kernel features. So if you have an Ubuntu image and you want to run it on Docker on a Windows or Mac computer you will not be able to without a VM because Mac and Windows do not use the Linux kernel.
So the system calls made by the Ubuntu libraries will be useless because Mac and Windows kernel will not understand it.
That is why when running Docker on Mac or Windows, it first creates a Linux VM on which the containers are run. 
</p>

<p>
Another important aspect of containrization tools are the runtime engines.
The runtime engines are responsible for lifecycle of containers such as starting, running, pausing, and killing containers.
The runtime engines are also responsible for managing the containers resources.
The runtime engine uses namespaces to isolate processes thus making each container run in its own environment and cgroups which allocate and limit resouces for each container.
The runtime container has other jobs as well such as managing a container network which allows containers to communicate with each other and the host system.
</p>
</div>
</div>

<div id="outline-container-org49da2f8" class="outline-4">
<h4 id="org49da2f8">Advantages of Containerization</h4>
<div class="outline-text-4" id="text-org49da2f8">
<p>
There are many advantages to containerization.
The first major benefit is that they are lightweight.
Unlike the VMs where you need each VM to have an OS to run one application.
Containers can all share the same Linux kernel, thus each container only needs the libraries, dependencies, configurations, and application code to run the application making them lightweight and efficient.
</p>

<p>
Containers also have similar benefits to VMs. Each container are isolated from the host and other containers adding security. You can run different base images on different containers within the same host, containers are portable so all the configurations, libraries, and dependencies can be run in a different host making them easy to develop, test, and deploy. With containers you can also support versioning such as reverting back to a version.
</p>

<p>
However, what makes containers so much better to VMs are their scalability.
Since containers are lightweight and efficient you can start many more containers in the same server than VMs in a different same-spec server.
This means you can scale at a better rate for the same cost.
Another benefit is that with dockers you can be very modular.
For example, let's say we only have one server with 3 VMs that run the same application.
We want to make our applications interact with another new application.
But since VMs are heavy we cannot start a new VM because all of our resources have been taken.
So what do we do?
We can make a VM have both applications but we already read the risks of that and that does not allow for great scalability in the future because it is not modular.
The last option would be to replace one VM for the new application but this will increase the workload on the other 2 VMs.
With containers we do not have this issue.
Since containers are lighter we can become modular and create a new container for the new application without having to stop another container running.
Plus, if we ever need to scale the new application we simply start another container with the new application.
Thus we can scale our older or newer applications without compromising already running containers.
</p>

<p>
Finally, the last major benefit is dynamic resource allocation. While many VMs have static resource allocation, for example, VM1 will receive 30% of the resources and that is fixed. It does not matter if VM1 will use all of the resources or none of them, 30% of resources will be allocated to VM1, nothing more nothing less.
In containerization you can allocate resources to a container but also specify the maximum limit of resources it can use if available.
This a great way to dynamically allocate resources.
For example, let's say we have 3 containers and 2 of the containers are idle while the 3rd is using all the resources it has been allocated.
However, its maximum or limit is higher.
Then the container will use resources that are not being used from the other two containers.
In addition, all containers will be able to use resources that is not being used from the host.
So containers are efficient when it comes to resource allocation because dynamically they can share resources between containers and the host.
</p>
</div>
</div>

<div id="outline-container-org90ec966" class="outline-4">
<h4 id="org90ec966">Disadvantages of Containers</h4>
<div class="outline-text-4" id="text-org90ec966">
<p>
Containers have a couple cons as well. One of the cons of containers is that they all share the same host kernel which can lead to security issues.
If the host kernel has some security vulnerability then all containers are exposed to such vulnerability.
Another issue is the complexity of setting up, scaling, and managing large scale environments with numerous amounts of dockers.
Containers are stateless and each time they run it behaves like if it were to be run for the first time, this is good in some scenarios, but again it can add complexity when trying to create persistent data.
</p>
</div>
</div>
</div>

<div id="outline-container-org1bd4224" class="outline-3">
<h3 id="org1bd4224">Docker</h3>
<div class="outline-text-3" id="text-org1bd4224">
<p>
According to <a href="https://aws.amazon.com/docker/">Amazon</a>, Docker is a software platform that allows you to build, test, and deploy applications quickly by packaging software into standardized units called containers that have everything the software needs to run including libraries system tools, code, and runtime.
</p>

<p>
Docker itself has a lot of tools and uses. One of the tools is containerization so Docker is one of the containerization technologies on the market. There are other containzerization tools in the market like Cloud Foundry but all containerization tools follow a similar process.
</p>

<p>
First, you create a docker file or a manifest. This docker file describes the steps to build the docker image or container image.
The docker file will describe all the dependencies, libraries, code, variables, and configurations.
The whole purpose of the docker file is to describe how to create a docker image.
So from a docker file you create a docker image. Think of the docker image as a read-only snapshot of a container.
The image now actually includes the application code, libraries, environment variables, and any other dependency.
Images are immutable once built.
If you need to introduce some other library or other code you will need to describe it in the docker file and build the image again.
From the docker image you can now create as many containers as you would like.
The containers are actual running instances of the docker image.
</p>

<p>
So in summary, Docker has many tools to test, build, and deploy applications.
Docker is a containerization technology that creates and builds containers.
To create a container in docker it is a 3 step process.
You first create a docker file.
A docker file is a build script that has instructions in how to create a docker image.
The docker file describes all the libraries, variables, and code
Using the docker file you build the docker image.
The docker image has the libraries, code, variables, configurations, etc. and docker images are immutable.
If you need to make changes to the docker image you will need to modify the docker file and build again.
Using the docker image you can create as many containers as you would like.
Containers are the actual running instance of the docker image.
</p>

<p>
Docker has played a huge role on how we deploy applications.
Now it is time to try out docker for ourselves.
</p>
</div>
</div>
</div>

<div id="outline-container-org73c642d" class="outline-2">
<h2 id="org73c642d">Using Docker</h2>
<div class="outline-text-2" id="text-org73c642d">
<p>
In order to use Docker we need to create an application.
I'm going to create a simple web application.
This web application will have a form to enter a name and age.
Once the form is submitted the name and age will appear below the form.
If there are already names and ages from previous submissions then it will also appear below the form.
The results will be shown in a table like structure and results will be shown from previous submissions, if any, as soon as the page is loaded.
The results table will have an id, timestamp, name, age, and it will have two buttons.
One button will edit the name and age.
The other button will delete the submission.
</p>

<p>
We will divide this project into 3 parts.
The first part is the web server and we will be using <a href="https://httpd.apache.org/">Apache HTTP Server</a>. 
The second part is the application (backend) server which we will be using <a href="https://www.djangoproject.com/">Django</a>.
The final part will be the database. We will use <a href="https://www.mysql.com/">MySQL</a> as our database.
</p>

<p>
Finally, each part of the project will be placed inside a docker container and ran.
We will not create multiple running containers of the same docker image because this is suppose to be a small project and load balancing is another project within itself.
</p>

<p>
Let's get started.
</p>
</div>

<div id="outline-container-orgc1f21f0" class="outline-3">
<h3 id="orgc1f21f0">Apache HTTP Server</h3>
<div class="outline-text-3" id="text-orgc1f21f0">
<p>
I'm not too familiar with Apache HTTP Server so let's start in the <a href="https://httpd.apache.org/docs/2.4/getting-started.html">documentation</a> and take notes.
All of the information below is taken from the documentation.
I will be using WSL 2 on Windows 11.
</p>
</div>

<div id="outline-container-org0ac43cf" class="outline-4">
<h4 id="org0ac43cf">Clients, Servers, &amp; URLs</h4>
<div class="outline-text-4" id="text-org0ac43cf">
<ul class="org-ul">
<li>Addresses on the web are expresed with URLs</li>
<li>They have a protocol (e.g. <code>http</code>), a servername (e.g. <code>www.apache.org</code>), a URL-path (<code>e.g. /docs/current/getting-started.html</code>), and possibly a query string (e.g. <code>?arg=value</code>) used to pass additional arguments to the server</li>
<li>A client (e.g. web browswer) connects to a server (e.g. my Apache HTTP Server running)</li>
<li>The client specifies the protocol and makes a request for a resource using the URL-path</li>
<li>The resource may be a file (e.g. <code>index.html</code>), a handler like a server-status, or some kind of program file (e.g. <code>index.php</code>)</li>
<li>The server will send a response consisting of a status code, and optionally, a response body</li>
</ul>
</div>
</div>

<div id="outline-container-orge9d62e5" class="outline-4">
<h4 id="orge9d62e5">Hostnames &amp; DNS</h4>
<div class="outline-text-4" id="text-orge9d62e5">
<ul class="org-ul">
<li>The client has to resolve the servername to an IP address</li>
<li>Thus for the web server to be reachable it is necessary that the servername be in the DNS (domain name system) so clients can map the servername into IP addresses</li>
<li>More than one IP address can be attached to the same physical server using virtual hosts</li>
<li>Thus when you type in a domain name it will find the IP address that pertains to that domain name and with the IP address the client will know which machine to send the request to</li>
<li>For example, if you wanted to you could use the IP address when entering server names in the browser instead of the domain name, this will skip the process of having to find the IP address of the domain name</li>
<li>Within the machine / server, it will use the endpoint (URL-path) to find, within its own machine, the resource the client is looking for</li>
<li>If your server is not internet-accessible, for example, for whatever reason your web server is not in the DNS and your client cannot resolve a server name (e.g. <code>www.example.com</code>) then you can make your client resolve the server name locally instead of using the DNS</li>
<li>You do this by modifying your machine's hosts file</li>
<li>This file has the IP address of any server names the user has added manually</li>
<li>So you can add <code>127.0.0.1 www.example.com</code> this will map the server name to the localhost</li>
<li>In Windows it is in <code>C:\Windows\system32\drivers\etc\hosts</code> and in Linux it is in <code>/etc/hosts</code></li>
<li>Another option is to simply use the IP address instead of a server name</li>
<li>When you are using the IP address it doesn't need the DNS or the hosts file because it knows which machine to request the resource from either from the local machine or some remote machine.</li>
</ul>
</div>
</div>

<div id="outline-container-orge177ba7" class="outline-4">
<h4 id="orge177ba7">Configuration Files &amp; Directives</h4>
<div class="outline-text-4" id="text-orge177ba7">
<ul class="org-ul">
<li>Apache HTTP Server is configured via simple text files</li>
<li>These files may be located on a variety of places depending on how the server was installed</li>
<li>For example, the default location of configuration files is <code>/usr/local/apache2/conf</code> and the default configuration file is called <code>httpd.conf</code> but this too can vary</li>
<li>The configuration is then broken into multiple smaller files for ease of management and these files are loaded via the <code>Include</code> directive</li>
<li>The files can be rearrange to whatever makes sense for you</li>
<li>The server is configured by placing configuration directives in these configuration files and a directive is a keyword followed by one or more arguments that set its value</li>
<li>Depending on where you want the directive to be effective is the file you place the directive, for example, if you want it as a global setting it should appear in the configuration file outside of any directory, location, virtual host, or other section</li>
<li>If you need to apply it to a particualar directory you then place it inside a directory section referring to that directory and so on</li>
<li>Certain directives may go in the <code>.htaccess</code> files located in the content directories, <code>.htaccess</code> files are primarily for people who do not have access to the main server configuration files</li>
</ul>
</div>
</div>

<div id="outline-container-org5aa4589" class="outline-4">
<h4 id="org5aa4589">Web Site Content</h4>
<div class="outline-text-4" id="text-org5aa4589">
<ul class="org-ul">
<li>Web site content can take many forms but can be broadly divided into static or dynamic content</li>
<li>Static conent are files that reside in the filesystem (html, css, js, etc.) and the <code>DocumentRoot</code> directive specifies where in your filesystem you should place these files</li>
<li>The directive is set globally or per virtual host but you have to take a look at your server to determine how this is set up in you</li>
<li>Typically a document called <code>index.html</code> will be served when a directory is requested without a file name being specifie, for example, if <code>DocumentRoot</code> is set to <code>/var/www/html</code> and the request is made for <code>http://www.example.com/work/</code> then the file <code>/var/www/html/work/index.html</code> will be served to the client</li>
<li>Dynamic content is anything that is generated at request time and there are numerous ways to generate dynamic content</li>
<li>Various handlers can generate content</li>
</ul>
</div>
</div>

<div id="outline-container-orgb6047e9" class="outline-4">
<h4 id="orgb6047e9">Log Files &amp; Troubleshooting</h4>
<div class="outline-text-4" id="text-orgb6047e9">
<ul class="org-ul">
<li>There are a couple of log files that may help you in time of troubleshooting</li>
<li>One of them is the error log which is defined by the <code>ErrorLog</code> which may be set globally or per virtua host</li>
</ul>
</div>
</div>

<div id="outline-container-orgdcde349" class="outline-4">
<h4 id="orgdcde349">Installing</h4>
<div class="outline-text-4" id="text-orgdcde349">
<div class="org-src-container">
<pre class="src src-bash">sudo apt install apache2

# Apache automatically starts to run after installing
# Check status
sudo systemctl status apache2

# To stop Apache
sudo systemctl stop apache2

# To start Apache
sudo systemctl start apache2
</pre>
</div>

<ul class="org-ul">
<li>The main configuration file: <code>/etc/apache2/apache2.conf</code></li>
<li>Listening ports config file: <code>/etc/apache2/ports.conf</code></li>
<li>More config files inside <code>/etc/apache2/mods-enabled/</code>, <code>/etc/apache2/conf-enabled</code>, and <code>/etc/apache2/sites-enabled/</code></li>
<li>According to the main config file the directories above have configuration snippets which manage modules, global configuration fragments, or virtual host configurations</li>
<li>How do you activate these configurations after some change?</li>
<li>They are activated by creating symlinks from the configuration in <code>*-available</code> to their <code>*-enabled</code> counterparts</li>
<li>This means to add some configuration change to Apache, you first do the change in <code>*-avaiable</code></li>
<li>Then Apache has command tools to enable or disable the configuration by running <code>a2enmod/a2dismod</code>, <code>a2ensite/a2dissite</code>, and <code>a2enconf/a2disconf</code></li>
<li>Each command tool enables or disables the new configurations for <code>mods-*</code>, <code>conf-*</code>, and <code>sites-*</code> directories</li>
</ul>
</div>
</div>

<div id="outline-container-orgbcb5b14" class="outline-4">
<h4 id="orgbcb5b14">Configuring Apache</h4>
<div class="outline-text-4" id="text-orgbcb5b14">
<ul class="org-ul">
<li>If we take a look at the enabled sites config <code>/etc/apache2/sites-enabled/000-default.conf</code> we see that the <code>DocumentRoot</code> is specified as <code>/var/www/html</code></li>
<li>We can change the value in <code>/etc/apache2/sites-available/000-default.conf</code>, if we'd like but we'll leave it how it is</li>
<li>Now let's take a look at the port and default file</li>
<li>By default if we have Apache running and go to <code>http://localhost/index.html</code> it should return with the file <code>index.html</code></li>
<li>The default port specified in <code>ports.conf</code> says 80 but we can change this as well, port 80 does not need to be specified in the URL because the browser uses port 80 for http</li>
<li>If we type <code>http://localhost/</code> the <code>index.html</code> file does not appear because we have to specify the <code>DirectoryIndex</code> directive to specify which file it should serve when a directory is accessed</li>
<li><p>
So we are going to change the port number and add a <code>DirectoryIndex</code>
</p>

<div class="org-src-container">
<pre class="src src-bash"># Replace default port
sudo sed -i '0,/Listen 80/s/Listen 80/Listen 8080/' /etc/apache2/ports.conf

# Restart Apache
sudo systemctl restart apache2

# Check status of Apache
sudo systemctl status apache2

# Update the Virtual Host Port
sudo sed -i '0,/&lt;VirtualHost \*:80&gt;/s/&lt;VirtualHost \*:80&gt;/&lt;VirtualHost \*:8080&gt;/' /etc/apache2/sites-available/000-default.conf

# Add default directory index so index.html will be requested by default w/o specifying it in the url
sudo sed -i '/DocumentRoot \/var\/www\/html/a\\tDirectoryIndex index.html' /etc/apache2/sites-available/000-default.conf

# Check config syntax
sudo apache2ctl configtest

# Enable site
# This is not needed because 000-default.conf is already enabled
# Thus if you make changes to a config file in the available folder that is already enabled (shown in the sites-enabled folder)
# Then all you need is to restart or reload apache to get the new changes
# Only do this if you create or change a config file that is not enabled (not present in sites-enabled)
sudo a2ensite 000-default.conf

# Should we reload or restart apache?
# Reload will realod the configuration files without fully stopping Apache and disrupt existing connections
# Restart stops and starts Apache again and will terminate all current connections
# Let's reload the configurations we did
sudo sytemctl reload apache2

# So now if you go to http://localhost:8080 then it will automatically pull index.html
</pre>
</div></li>

<li>So now we have successfully setup Apache, changed the port and added a directive to automatically pull index.html</li>
<li>Now it is time to create our front-end of the application</li>
<li>We will create a new directory in called <code>What_is_Docker</code> thus its path will be <code>/var/www/html/What_is_Docker/</code> and inside it will have the file <code>index.html</code></li>
<li>So now if we go to <a href="http://localhost:8080/What_is_Docker">http://localhost:8080/What_is_Docker</a> the index file inside <code>What_is_Docker</code> directory should appear</li>
<li><a href="./App/Frontend/index.html">Here</a> is the index file</li>
</ul>
</div>
</div>

<div id="outline-container-orgac120a8" class="outline-4">
<h4 id="orgac120a8">Creating A Docker File &amp; Docker Image</h4>
</div>
</div>

<div id="outline-container-org5132346" class="outline-3">
<h3 id="org5132346">Django</h3>
<div class="outline-text-3" id="text-org5132346">
<p>
We will be following the <a href="https://docs.djangoproject.com/en/5.1/">Django docs</a> to create our backend server.
</p>
</div>

<div id="outline-container-org1fb79fe" class="outline-4">
<h4 id="org1fb79fe">Creating Django Project</h4>
<div class="outline-text-4" id="text-org1fb79fe">
<div class="org-src-container">
<pre class="src src-bash"># Download python
sudo apt install python3

# Create venv
python3 -m venv myvenv

# Activate venv
source myvenv/bin/activate

# Download Django
pip install Django

# Bootstrap new project
django-admin startproject &lt;project-name&gt;

# Move directory
cd &lt;project-name&gt;

# Start server
python manage.py runserver

</pre>
</div>

<ul class="org-ul">
<li>Django will create a <code>manage.py</code> which allows you interact with this Django project in various ways</li>
<li><code>settings.py</code> are the settings and configurations of the Django project</li>
<li><code>urls.py</code> is the URLs declarations for the Django project</li>
</ul>
</div>
</div>
</div>
</div>






<div id="outline-container-orge892c91" class="outline-2">
<h2 id="orge892c91">Resources</h2>
<div class="outline-text-2" id="text-orge892c91">
<p>
<a href="https://medium.com/@suryasaravanan2002/history-of-how-deployment-used-to-work-how-containerization-revolutionized-it-da785f4573ca#:~:text=In%20the%20early%20days%20of,of%20deployment%20that%20was%20used">https://medium.com/@suryasaravanan2002/history-of-how-deployment-used-to-work-how-containerization-revolutionized-it-da785f4573ca#:~:text=In%20the%20early%20days%20of,of%20deployment%20that%20was%20used</a>
</p>

<p>
<a href="https://www.vmware.com/topics/virtual-machine">https://www.vmware.com/topics/virtual-machine</a>
</p>

<p>
<a href="https://www.redhat.com/en/topics/virtualization/what-is-a-virtual-machine">https://www.redhat.com/en/topics/virtualization/what-is-a-virtual-machine</a>
</p>

<p>
<a href="https://www.techtarget.com/searchitoperations/tip/Whats-the-difference-between-Type-1-vs-Type-2-hypervisor">https://www.techtarget.com/searchitoperations/tip/Whats-the-difference-between-Type-1-vs-Type-2-hypervisor</a>
</p>

<p>
<a href="https://aws.amazon.com/what-is/containerization/">https://aws.amazon.com/what-is/containerization/</a>
</p>

<p>
<a href="https://www.ibm.com/think/topics/containerization">https://www.ibm.com/think/topics/containerization</a>
</p>

<p>
<a href="https://www.youtube.com/watch?v=eyNBf1sqdBQ">https://www.youtube.com/watch?v=eyNBf1sqdBQ</a> (Virtual Machines vs Containers by PowerCert Animated Videos)
</p>

<p>
<a href="https://www.youtube.com/watch?v=0qotVMX-J5s">https://www.youtube.com/watch?v=0qotVMX-J5s</a> (Containerization Explained by IBM Technology)
</p>

<p>
<a href="https://aws.amazon.com/docker/">https://aws.amazon.com/docker/</a>
</p>
</div>
</div>
</div>
</body>
</html>
