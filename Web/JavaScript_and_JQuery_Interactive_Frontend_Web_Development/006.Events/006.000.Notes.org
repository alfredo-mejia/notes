#+title: Chapter 6: Events
#+author: Alfredo Mejia
#+options: num:nil html-postamble:nil
#+html_head: <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css" /> <style>body {margin: 5%} h1,h2,h3,h4,h5,h6 {margin-top: 3%} .content ul:not(:first-child) {margin-top: 0.25em}}</style>

* Navigation
| Nav   | Title                                                       | Links                                   |
|-------+-------------------------------------------------------------+-----------------------------------------|
| Index | Notes Home                                                  | \vert [[file:../../../index.html][html]] \vert [[file:../../../index.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main][github]] \vert |
| Home  | JavaScript & JQuery - Interactive Front-end Web Development | \vert [[file:../000.Home.html][html]] \vert [[file:../000.Home.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development][github]] \vert |
| Prev  | Chapter 5: Document Object Model                            | \vert [[file:../005.Document_Object_Model/005.000.Notes.html][html]] \vert [[file:../005.Document_Object_Model/005.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/005.Document_Object_Model][github]] \vert |
| Next  | Chapter 7: jQuery                                           | \vert [[file:../007.jQuery/007.000.Notes.html][html]] \vert [[file:../007.jQuery/007.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/007.jQuery][github]] \vert |

* Notes
** Section 6.1: Introduction to Events
   - When you browse the web, your browser registers different types of events
   - It is the browser's way of saying "Hey, this just happened"
   - For example, whenever you click on a button, the browser knows you clicked on the button and it can register an event for that scenario, so whenever a user clicks a button the browser can tell you that button has been clicked
   - Your script can then respond to these events
   - Scripts often respond to these events by updating the content of the web page (via DOM) which makes the page feel more interactive
   - Events occur when users click or tap on a link, hover or swipe over an element, type on the keyboard, resize the window, or when the page they request has loaded
   - When an event occurs, or fies, it can be used to trigger a particular function and different code can be triggered when users interact with different parts of the page
   - This code can then use the DOM to update the page and thus the web page is interacting with the user

** Section 6.2: Event Types
   - When an event has occurred it is often described as having *fired* or been *raised*
   - So for example the user clicks on a button, the /click/ event would be fired in the browser
   - Events are said to trigger a function or script
   - So in code, if the /click/ event is fired it could trigger more code or other scripts
   - This means in the browser events are *always* fired even if they do not trigger any function or script or even if the developer does not "handle" any event
   - The events in the browser will happen regardless of your JS code, so it is up to the developer to make it trigger some code or not
   - Here are the following different types of events:

   | Type of Event   | Event                         | Description                                                                                            |
   |-----------------+-------------------------------+--------------------------------------------------------------------------------------------------------|
   | UI Events       | ~load~                        | Web page has finished loading                                                                          |
   | UI Events       | ~unload~                      | Web page is unloading (usually because a new page was requested)                                       |
   | UI Events       | ~error~                       | Browser encounters a JS error or an asset does not exist                                               |
   | UI Events       | ~resize~                      | Browser window has been resized                                                                        |
   | UI Events       | ~scroll~                      | User has scrolled up or down the page                                                                  |
   | Keyboard Events | ~keydown~                     | User first presses a key (repeats while key is depressed)                                              |
   | Keyboard Events | ~keyup~                       | User releases a key                                                                                    |
   | Keyboard Events | ~keypress~                    | Character is being inserted (repeats while key is depressed)                                           |
   | Mouse Events    | ~click~                       | User presses and releases a button over the same element                                               |
   | Mouse Events    | ~dbclick~                     | User presses and releases a button twice over the same element                                         |
   | Mouse Events    | ~mousedown~                   | User presses a mouse button while over an element                                                      |
   | Mouse Events    | ~mouseup~                     | User releases a mouse button while over an element                                                     |
   | Mouse Events    | ~mousemove~                   | User moves the mouse (not on a touchscreen)                                                            |
   | Mouse Events    | ~mouseover~                   | User moves the mouse over an element (not on a touchscreen)                                            |
   | Mouse Events    | ~mouseout~                    | User moves the mouse off an element (not on a touchscreen)                                             |
   | Focus Events    | ~focus~ / ~focusin~           | Element gains focus                                                                                    |
   | Focus Events    | ~blur~ / ~focusout~           | Element loses focus                                                                                    |
   | Form Events     | ~input~                       | Value in any ~<input>~ or ~<textarea>~ has changed or any element with the ~contenteditable~ attribute |
   | Form Events     | ~change~                      | Value in select box, checkbox, or radio button changes                                                 |
   | Form Events     | ~submit~                      | User submits a form (using a button or key)                                                            |
   | Form Events     | ~reset~                       | User clicks on a form's reset button (rarely used these days)                                          |
   | Form Events     | ~cut~                         | User cuts content from a form field                                                                    |
   | Form Events     | ~copy~                        | User copies content from a form field                                                                  |
   | Form Events     | ~paste~                       | User pastes content into a form field                                                                  |
   | Form Events     | ~select~                      | User selects some text in a form field                                                                 |
   | Mutation Events | ~DOMSubtreeModified~          | Change has been made to document                                                                       |
   | Mutation Events | ~DOMNodeInserted~             | Node has been inserted as a direct child of another node                                               |
   | Mutation Events | ~DOMNodeRemoved~              | Node has been removed from another node                                                                |
   | Mutation Events | ~DOMNodeInsertedIntoDocument~ | Node has been inserted as a descendant of another node                                                 |
   | Mutation Events | ~DOMNodeRemovedFromDocument~  | Node has been removed as a descendant of another node                                                  |

** Section 6.3: How Events Trigger JS Code
   - When the user interacts with the HTML on a web page there are 3 steps involved in getting it to trigger some JS code and together these steps are known as event handling
     1. Select the element node(s) you want the script to respond to (for example, if you want to trigger a function when a user clicks on a specific link you need to get the DOM node for that link element)
     2. Indicate which event on the select node(s) will trigger the response (programmers call this binding an event to a DOM node, so if you want to "bind" or respond to a mouse event specify "mousedown" or any other event)
     3. State the code you want to run when the event occurs (when the event occurs on a specified element, it will trigger a function it can be a named or anonymous function)
   - The user interface events that related to the browser window (rather than the HTML page loaded in it) work with the ~window~ object rather than an element node (example includes the events that occur when a requested page has finished loading or when the user scrolls)
   - Some events work with most element nodes, such as the ~mouseover~ event which is triggered when the user rolls over any element but other events only work with specific element nodes such as the ~submit~ event which only works with a form
   - Event handlers let you indicate which event you are waiting for on any particular element

*** Section 6.3.1: HTML Event Handlers
    - HTML event handlers are bad practice and should not be used
    - Early versions of HTML included a set of attributes that could respond to events on the element they were added to
    - The attribute names matched the event names and their values called the function that was to run when the event occurred
    - For example the following: ~<a onclick="hide()">~ indicated that when a user clicked on this ~<a>~ element the ~hide()~ function would be called
    - This method of event handling is no longer used because it is better to separate JS from HTML
    - In HTML, the first ~<input>~ element has an attribute called ~onblur~ (triggered when the user leaves the element) and the value of the attribute is the name of the function that it should trigger
    - The value of the event handler attributes would be JavaScript and often the JS would be written in the ~<head>~ element or a separate JS file
    - The names of the HTML event handler attributes are identical to the event names shown previously except that they are preceded by the word "on" (e.g. ~onclick~, ~onblur~, ~onmousemove~, etc.)
    - ~<a>~ elements have ~onclick~, ~onmouseover~, ~onmouseout~, etc.
    - ~<form>~ elements can have ~onsubmit~
    - ~<input>~ elements for text can have ~onkeypress~, ~onfocus~, ~onblur~, etc. 

*** Section 6.3.2: Traditional DOM Event Handlers
    - DOM *event handlers* were introduced in the original specification for DOM and are considered better than HTML event handlers because they let you separate the JS from the HTML
    - The drawback of DOM event handlers is that you can only attach a single function to any event thus if you have more than one script used on the same page and both scripts respond to the same event then one or both of the scripts may not work as intended
    - All modern browsers understand this way of creating an event handler but you can only attach one function each event handler
    - Here is the syntax to bind an event to an element using an event handler and to indicate which function should execute when the event fires:

    #+BEGIN_SRC javascript
      element.onevent = functionName;
    #+END_SRC

    - "element" is a placeholder for the actual element object
    - "onevent" is a placeholder for the event bound to the node(s) preceded by the word "on"
    - "functionName" is a placeholder to the name of the function to call without parentheses following it
    - For example:

    #+BEGIN_SRC javascript
      function checkUsername() {
      }

      var el = document.getElementById(<id>);
      el.onblur = checkUsername;
    #+END_SRC

    - Notice how the parentheses are omitted from the function in the event handler
    - This is an example of an event handler using named functions
    - You could also use anonymous functions like the following: ~el.onblur = function (){}~
    - Also remember when using event handlers, the event name is preceded by the word "on"
    - You cannot pass arguments to the function, you will need to do a workaround to pass argumments (data) to the function
    - Also note that when assigning functions to an element's event, in the function you can use the keyword ~this~ and it would refer to the element object because the function was called from the element's event being fired
    - Since we cannot pass arguments to the functions in event handlers we need a workaround and that workaround is to wrap the function call in an anonymous function
    - For example, instead of ~el.onblur = checkUsername~ without any arguments we run the following ~el.onblur = function() {checkUsername(argument)}~
    - Thus the event handler only sees one function with no arguments but inside the argument you call the true event handler function with some arguments
       
*** Section 6.3.3: DOM Level 2 Event Listeners
    - *Event listeners* were introduced to an update to the DOM specification and they are now the favored way of handling events
    - The syntax is different from the traditional (old) event handlers and allows one event to trigger multiple functions, thus there are less likely to be conflicts between different scripts that run on the same page
    - Another reason why jQuery became popular because in the old browsers there were differences in browser support for DOM and events
    - Event listeners allow for multiple listeners to be attached to the same event and it does not overwrite any existing listeners
    - Event listeners are more modern as they support more than one function at a time but are not supported in older browsers (which doesn't apply anymore because every modern browser supports it now)
    - Here is the syntax to bind an event to an element using an event listener which indicates which function should execute when the event fires on the specified element

    #+BEGIN_SRC javascript
      element.addEventListener('event', functionName, [, Boolean]);
    #+END_SRC

    - "element" is the DOM element node to target
    - "event" is the event to bind Node(s) to in quotation marks
    - "functionName" is the name of the function or it could be an anonymous function
    - The last part of the syntax indicates something called capture and is usually set to false (we'll talk about it more later) and the last part (parameters inside the square brackets) is optional
    - For example:

    #+BEGIN_SRC javascript
      function checkUsername() {}
      var el = document.getElementById('username');
      el.addEventListener('blur', checkUsername, false);
    #+END_SRC

    - An anonymous function can also be used as the following: ~el.addEventListener('blur', function(){}, false)~
    - The ~addEventListener()~ method takes 3 parameters:
      1. The event you want it to listen for
      2. The code that you want it to run when the event fires (notice if you are using named functions you need to omit the parentheses because that would mean you are calling the function but that is incorrect, the function will be called only when the event is fired / raised so omit the parentheses)
      3. A boolean indicating how events flow (we'll talk about it later)
    - Note that unlike HTML handlers and traditional DOM event handlers when you specify the name of the event that you want to react to, the event name is not preceded by the word "on"
    - If you want to remove an event listener, there is a function called ~removeEventListener()~ which removes the event listener from the specified element and it has the same parameters as ~addEventListener()~
    - One workaround to pass arguments is to enclose the function in the event listener in an anonymous function and call the original function inside the anonymous function with the appropriate arguments
    - For example, instead of ~el.addEventListener('blur', checkUsername, false)~ without any arguments we call ~el.addEventListener('blur', function() {checkUsername(5)}, false)~
    - To pass arguments from other the event listener to the function, the most common and natural way, is to simply use the variables exposed based on scope, in JS, you can define variables outside the event listener and be able to access them inside the event listener due to how scope works in JS

**** Section 6.3.3.1: Supporting Older Versions of Internet Explorer (IE) - OUTDATED!!
     - IE8 and earlier do not support ~addEventListener()~ but you can provide fallback code to make event listeners work with older versions of IE
     - Instead of ~addEventListener()~ it uses its own method called ~attachEvent()~ which does the same job (accepts the event name preceded by the word "on" and a function) but only available in IE
     - Thus to support IE8 or earlier you use an if-else statement, you check if ~addEventListener~ exists by running ~if(element.addEventListener)~, if it returns true then you can use ~addEventListener~ and if it returns false you use the else statement to run ~attachEvent~
     - When ~attachEvent()~ is used the event name should be preceded by the word "on" (e.g. "onblur")
     - If you need to support IE8 or older, instead of writing this fallback code for every event it is better to write your own helper function that creates the event hanlder for you for whichever method it supports (~addEventListener~ or ~attachEvent~) so instead of writing this if-else multiple times, you write it once in your helper function and now you use your helper function to create events

** Section 6.4: Event Flow
   - HTML elements nest inside other elements and if you hover or click on a link or other element, you will also be hovering or clicking on its parent elements
   - Let's take for example a link using the element ~<a>~, when you hover over the link or click on it, JS can trigger events on the ~<a>~ element and also any elements ~<a>~ element sits inside
   - Event handlers / listeners can be bound to the containing ~<li>~, ~<ul>~, ~<body>~, and ~<html>~ elements, plus the ~document~ object and the ~window~ object and the order in which the events fire is known as *event flow* and events flow in *two* directions
   - Event bubbling: The event starts at the /most/ specific node and *flows outwards* to the least specific one or the outter most node, so this event flow goes from the inner most node (element that was clicked or hover) to the outter most node (the greatest grandparent of the element)
   - Event bubbling is the default type of event flow with very wide browser support
   - Event capturing: The event starts at the least specific node (or the outter most node / gratest grandparent of the element) and *flows inwards* to the most specific node thus traveling through its descendants (the element that was clicked or hovered)
   - Event capturing is not supported in IE8 or earlier
   - It all depends on the *originating element*, so for *event bubbling* it goes from the originating element to the farthest ancestor that has an event handler and for *event capturing* it starts at the farthest ancestor and continues through its descendants to finally reach the event handler of the originating element
   - Note that if there is any children with event handlers from the originating element, those elements will not be called because their events were not fired, thus the only elements in question is the originating elements and all its ancestors (not its children) and the event flow is concerned only with the order in which event handlers are fired
   - By default modern browsers use event bubbling
   - With event listeners, the final and third parameter in the ~addEventListener()~ method lets you choose the direction to trigger events: true is for capturing phase and false is for the bubbling phase (default)

** Section 6.5: Event Object
   - When an event occurs, the event object tells you information about the event and the element it happened upon
   - Every time an event fires, the ~event~ object contains helpful data about the event such as:
     - Which element the event happened on
     - Which key was pressed for a ~keypress~ event
     - What part of the viewport the user clicked for a ~click~ event (the viewport is the part of the browser window that shows the web page)
   - The ~event~ object is passed to any function that is the event handler or listener
   - If you need to pass arguments to a named function (including the event object) then the ~event~ object will first be passed to the anonymous wrapper function (this happens automatically) then you must specify it as a parameter to the named function so your named function can get all the arguments including the event object
   - When the event object is passed into a function it is often given the parameter name ~e~ (for event) but other developers may use the letter ~e~ to mean error objects as well, so ~e~ can have multiple meanings depending on the context
   - IE8 had different syntax for event listeners but also for properties and methods of the event object
   - For example, usually the event object has a property named ~target~ which is the target of the event (most specific element interacted with) but in IE8 it is called ~srcElement~, another property is ~cancelable~ but IE8 does not support it, methods like ~preventDefault()~ and ~stopPropagation()~ are properties in IE8 called ~returnValue~ and ~cancelBubble~
   - Note that the function given for the hanlder or listener will always be called with a reference to the event object but it is up to the function to give it a name or not, if no name is given then you won't be able to use it (because you can't reference it with a variable name), but if you do give a name then the event object can be used inside the function but the event object is automatically and always passed to the function even if you have a named parameter or not
   - In IE8 and lower, the event object is not passed automatically to the event handler / listener functions but it is available as a child of the ~window~ object so instead of getting the event object as an argument you would have to get it from the window object as follows: ~window.event~
   - So to support IE8 and lower, you can add a parameter to the function, check if it is not null, if it is then use the ~window.event~ instead of the parameter since it is null, otherwise just continue using the parameter
   - Then to use the properties you can do something like the following: ~let target = e.target || e.srcElement~ thus if ~e.target~ exists then it will assign it to the variable but if it does not then it will use ~e.srcElement~

** Section 6.6: Event Delegation
   - Creating event listeners for a lot of elements can slow down a page but event flow allows you to listen for an event on a parent element
   - If users can interact with a lot of elements on the page such as lots of buttons in the UI, a long list, every cell of a table, etc. adding event listeners to each element can use a lot of memory and slow down performance
   - Because events affect containing (or ancestor) elements due to event flow, you can place event handlers on a containing element and use the event object's target property to find which of its children the event happened on
   - By attaching an event listener to a containing element, you are only responding to one element rather than having an event handler for each child element
   - You are *delegating* the job of the event listener to a parent of the elements
   - For example, let's say we have a list using ~<ul>~ instead of adding event listeners for each ~<li>~ we add an event listener to ~<ul>~ and so when an event is fired we check which child fired the event and we do some work, this way we only have one event listener and if we add more ~<li>~ it should still work the same without any changes
   - Recall, events are going to be fired regardless if you have event listeners or not, and the default is event bubbling so it will go from the target element all the way to the ~document~ object through its ancestors
   - Thus, if we delegate events to one of the ancestors, we can have one event listener take care of all the work of its children or descendants, thus improving our performance and writing less code
   - Event delegation allow us to add new elements and not need to add event listeners to the new elements because the job has been delegated to an ancestor and it simplifies our code thus making it easier to maintain

*** Section 6.6.1: Which Element Did An Event Occur On?
    - When calling a function, the event object's ~target~ property is the best way to determine which element the event occured on
    - There are other ways to determine the "target" element by using the ~this~ keyword
    - Inside an event listener function, ~this~ keyword refers to the owner of a function and thus when an event listener invokes the function, ~this~ refers to the element that the event is on
    - This works when no parameters are being passed to the function and actually called from the event and not some anonymous function
    - Therefore it is *not* called from an anonymous function because if you call it from an anonymous function ~this~ won't refer to the event that is calling it but rather the anonymous funciton that called it, so you have to provide the function name as an argument to ~addEventListener()~ instead of passing an anonymous function
    - That is why you cannot pass arguments to the function because in order to pass arguments you need to create an anonymous function and call it from there and if that was case then the owner of the function is no longer the element that the event listener was bound to but the anonymous function
    - A workaround is that you could create two named functions, the first going as a listener handler, then using ~this~ you pass it as an argument to the next named function, however this would be bad practice
    - Finally, note that ~this~ is not a great way to determine the target element because ~this~ will refer to the element that called the function and in this case it would be the element that the event listener was added to, not the element that first fired the event
    - In other words, if you have a parent that has an event listener because you doing event delegation, and one of its children trigger an event, then the parent will be the element that will be calling the function so ~this~ will refer to the parent and not the child that the event occured on, so the developer would need to do more work to figure out which child triggered the event
    - This is why the ~event~ object is the preferred approach and the right approach

*** Section 6.6.2: Changing Default Behavior
    - The event object has methods that change the default behavior of an element and how the element's ancestors respond to the event
    - ~preventDefault()~:
      - Some events such as clicking on links and submitting forms, take the user to another page
      - To prevent the default behavior of such elements (e.g. to keep the user on the same page rather than following a link or being taken to a new page after submitting a form) you can use the event object's ~preventDefault()~ method
      - IE8 and earlier (up to IE5) have an equivalent property called ~returnValue~ which can be set to false
      - A conditional statement can check if the ~preventDefault()~ method is supported and if not then use IE8's approach
    - ~stopPropagation()~:
      - Once you have handled an event using one element, you may want to stop that event from bubbling up to its ancestor elements especially if there are separate event handlers responding to the same events on the containing elements
      - To stop the event bubbling up you can use the event object's ~stopPropogation()~ method
      - The equivalent in IE8 and earlier is the ~cancelBubble~ property which can be set to true
      - Again, a conditional statement can check if the ~stopPropagation()~ method is supported and if not then use IE8's approach
    - Before in older JS, there could be situations where we run ~return false~ in a event listener function and that would prevent the default behavior of the element and prevents the event from bubbling up or capturing further, however that has changed in modern browsers
    - Returning false use to work in older event models and in jQuery but in modern browsers that does no longer work, it only works now in jQuery but it is now considered legacy shortcut so it is no longer recommended and in inline HTML event handlers but it is bad practice to have inline HTML event handlers
    - So in modern browsers returning false would not work and thus it requires to be explicit and clearly state ~preventDefault()~ and / or ~stopPropagation()~ for it to work

** Section 6.7: Different Types of Events
   - Events are defined in the W3C DOM specification, HTML5 specification, and in BOM (Browser Object Models)
   - The DOM events specification is managed by the W3C (who also look after other specifications including HTML, CSS, and XL) and most of the events you will meet in this chapter are part of this DOM events specification
   - Browsers implement all the events using the same ~event~ object which has properties and methods about the target element
   - W3C DOM events defined standardized events but not all events are covered in the DOM event model
   - Some events were introduced as part of HTML5 specification and often relate to the new HTML5 features such as media, form validation, and web APIs
   - Many HTML5 events are built on top of the W3C DOM events model and are often tied to the new HTML5 elements which try to focus user interaction with new HTML5 capabilities
   - BOM events are events associated with the Browser Object Model and are browser-sepcific or window-level events that involve global objects such as ~window~, ~navigator~, or ~screen~
   - BOM events deal with the browser environment and user's system and are either tired to the ~window~ or ~document~ object but some events are not part of the W3C DOM standard but supported by all modern browsers
   - Thus all modern browsers implement some events as part of their Browser Object Model (BOM) even if those events are not part of the W3C DOM specifications
   - However, web technologies move fast and standardization of events are rapid so events are constantly changing from some being depcreated to new ones being introduced

*** Section 6.7.1: User Interface Events
    - User interface (UI) events occur as a result of interaction with the browser window rather than the HTML page contained within it (e.g. a page having loaded or the browser window being resized)
    - The event handler / listener for UI events should be attached to the browser window (in old HTML5 event handlers you would use these events used as attributes on the opening ~<body>~ tag)

    | Event    | Trigger                                                                                                                                                             | Browser Support                                                                                                                                                                                                                                                                                        |
    |----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | ~load~   | Fires wehn the web page has finished loading and it can also fire on nodes of other elements that load such as images, scripts, or objects                          | The event can fire on the ~window~, ~document~, and other element objects such as ~<script>~, ~<img>~, and others but between ~window~ and ~document~ it is commonly used in ~window~ object                                                                                                           |
    | ~unload~ | Fires when the web page is unloading (usually because a new page has been requested)                                                                                | The event can fire on the ~window~ object and in older code it might fire on the ~body~ element object (e.g. ~document.body.onunload~) but ~unload~ event's primary and most reliable target is the ~window~ object but W3C recommends to not use this event due to reliability and performance issues |
    | ~error~  | Fires when the browser encounters a JS error or an asset does not exist                                                                                             | The event can fire on the ~window~ object or other element objects that can have errors such as images not being able to load, thus this error is good for JS errors and resource loading errors                                                                                                       |
    | ~resize~ | Fires when the browser window has been resized                                                                                                                      | Browsers repeatedly fire the ~resize~ event as the window is being resized so avoid using complicated and long code in this event because it will make your page and less responsive                                                                                                                   |
    | ~scroll~ | Fires when the user has scrolled up or down the page (it can related to the entire page or a specific element on the page such as ~<textarea>~ that has scrollbars) | Browsers repeatedly fire the event as the window is scrolled so avoid using complicated and long code for the event                                                                                                                                                                                    |

    - The ~load~ event is commonly used to trigger scripts that access the contents of the page
    - The ~load~ event is automatically raised by the ~window~ object when a page has finished loading the HTML and all of its resources: images, CSS, scripts (even third party content e.g. banner ads)
    - Recall the ~load~ event is added to the ~window~ object
    - Because the ~load~ event only fires when everything else on the page has loaded (images, scripts, and even ads) the user could have started to use the page before the script has started to run
    - Users may notice when a script changes the appearance of the page, change focus, or selects from elements after they started to use it and this would make the site looker slower to load
    - For example, let's say you have a form and you select an input but when the page loads it automatically focuses on another input (changing the cursor to other input) thus interrrupting the user and making the page seem slower

*** Section 6.7.2: Focus & Blur Events
    - The HTML elements you can interact with such as links and form elements can gain focus and these events fire when they gain or lose focus
    - If you interact with an HTML element, then it can gain and lose focus and you can also tab between the elements that can gain focus (a technique often used by those with visual impairments)
    - In older scripts, the ~focus~ and ~blur~ events were often used to change the apearance of an element as it gained focus, but now the CSS ~:focus~ pseudo-class is a better solution unless you need to affect an element /other/ than the one that gained focus
    - The focus and blur events are most commonly used on forms and can be helpful when you want to show tips or feedback to users as they interact with an individual element within a form (the tips / feedback are usually shown in other elements and not the one they are interacting with) or when you need to trigger form validation as a user moves from one control to the next rather than waiting for them to submit the entire form first

    | Event      | Trigger                                                                | Flow             |
    |------------+------------------------------------------------------------------------+------------------|
    | ~focus~    | When an element gains focus, the ~focus~ event fires for that DOM node | Capture          |
    | ~blur~     | When an element loses focus, the ~blur~ event fires for that DM ndoe   | Capture          |
    | ~focusin~  | Same as focus                                                          | Bubble & capture |
    | ~focusout~ | Same as blur                                                           | Bubble & capture |

    - The default behavior of ~focus~ is to call the event listener for the directly originating element, there is no bubbling or capture
    - ~focus~ event cannot bubble but it can capture, you would need to specify ~true~ as the 3rd argument to ~addEventListener()~
    - To bubble you would need to use ~focusin~ because by default it would bubble flow and to specify capture then it would specify ~true~ as the 3rd argument to ~addEventListener()~
    - So ~focus~ does not support bubble, by default it will only fire the event listener of the direct target element, and it can use capture flow by specifying ~true~ as the 3rd argument to ~addEventListener()~
    - ~focusin~ supports both bubble and capture, by default it would use bubble flow, and to use capture flow you would have to specify ~true~ as the 3rd argument to ~addEventListener()~

*** Section 6.7.3: Mouse Events
    - The mouse events are fired when the mouse is moved and also when its buttons are clicked
    - All of the elements on a page support the mouse events and all of these bubble
    - Note that actions are different on touchscreen devices
    - Prevetning a default behavior can have unexpected results because a ~click~ only fires when both ~mousedown~ and ~mouseup~ event has fired

    | Event       | Trigger                                                                                                                                                                                                                            | Touch                                                             |
    |-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------|
    | ~click~     | Fires when the user clicks on the primary mouse button, the ~click~ event will for the element that the mouse is currently overand it will also fire if the user presses the ~Enter~ key on the keyboard when an element has focus | A tap on the touchscreen will be treated like a single left-click |
    | ~dblclick~  | Fires when the user clicks the primary mouse button twice in quick succession (cannot be triggered by keyboard)                                                                                                                    | A double-tap will be treated as a double left-click               |
    | ~mousedown~ | Fires when the user clicks down on any mouse button (cannot be triggered by keyboard)                                                                                                                                              | You can use the ~touchstart~ event                                |
    | ~mouseup~   | Fires when the user releases a mouse button (cannot be triggered by keyboard)                                                                                                                                                      | You can use the ~touchend~ event                                  |
    | ~mouseover~ | Fires when the cursor was outside an element and is then moved inside it (cannot be triggered by keyboard)                                                                                                                         | Fires when the cursor is moved over an element                    |
    | ~mouseout~  | Fires when the cursor is over an element and then moves onto another element, outside of the current element or a child of it (cannot be triggered by keyboard)                                                                    | Fires when the cursor is moved off an element                     |
    | ~mousemove~ | Fires when the cursor is moved around an element, this event is repeatedly fired (cannot be triggered by keyboard)                                                                                                                 | Fires when the cursor is moved                                    |

    - ~mouseover~ and ~mouseout~ events were often used to change the appearance of boxes or to switch images as the user rolls over them but to change the appearance of the element it is best to use the CSS ~:hover~ pseudo-class
    - ~mousedown~ and ~mouseup~ events separate out the press and release of a mouse button and it is often used for adding drag and drop functionality or to add controls in game development
    - The ~click~ event can be applied to any element but it is better to only use it on items that are usually clicked or it will not be accessible to people who rely upon keyboard navigation
    - You may also be tempted to use the ~click~ event to run a script when a user clicks on a form element but it is better to use the ~focus~ event because that fires when the user accesses that control using the tab key

*** Section 6.7.4: Keyboard Events
    - The keyboard events are fired when a user interacts with the keyboard (they fire on any kind of device with a keyboard)

    | Event      | Trigger                                                                                                                                                                                                                                                                    |
    |------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | ~input~    | Fires when the value of an ~<input>~ or ~<textarea>~ element changes                                                                                                                                                                                                       |
    | ~keydown~  | Fires when the user presses any key on the keyboard and if the user holds down a key, the event continues to fire repeatedly                                                                                                                                               |
    | ~keypress~ | Fires when the user presses a key that would result in a character being shown on the screen (e.g. this event would not fire when the user presses the arrow key whereas the ~keydown~ event would and if the user holds down a key the event continues to fire repeatedly |
    | ~keyup~    | Fires when the user releases a key on the keyboard, the ~keydown~ and ~keypress~ events fire before a character shows on screen whereas ~keyup~ fires after it appears                                                                                                     |

    - The order of the events that start with key is the following:
      1. ~keydown~: User presses key down
      2. ~keypress~: User has pressed or is holding a key that adds a character into the page
      3. ~keyup~: User releases key

    - When you use the ~keydown~ or ~keypress~ events, the event object has a property called ~keyCode~ which can be used to tell which key was pressed
    - However it does not return the letter for that key instead it returns an ASCII code that represents the lowercase character for that key
    - To get the character from the ASCII code, the string object has a built-in method called ~String.fromCharCode(event.keycode)~ which will do the conversion from ASCII code to the character
    
*** Section 6.7.5: Form Events
    - There are two events that are commonly used with forms: ~submit~ and ~change~

    | Event    | Trigger                                                                                                                                                                                                                                                                                                   |
    |----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | ~submit~ | When a form is submitted, the ~submit~ event fires on the node representing the ~<form>~ element and it is often used for validation before sending it to the server                                                                                                                                      |
    | ~change~ | Fires when the status of several form elements change (e.g. dropdown selection was made, radio button is selected, checkbox is selected / deselected) and it is better to use than the ~click~ event because clicking is not the only way users interact with form elements (e.g. tab, arrow, enter keys) |
    | ~input~  | Fires when the value of an ~<input>~ or ~<textarea>~ element changes                                                                                                                                                                                                                                      |

    - The focus and blur events are often used with forms but they can also be used in other elements such as links so they are not specifically related to forms
    - Validation is an important part of forms so being able to do client-side validation is important because server-side validation takes longer and unexpected data sent to the server can lead to unexpected results

*** Section 6.7.6: Mutation Events & Observers
    - Whenever elements are added to or removed from the DOM, its structure changes and this change triggers a mutation event
    - When your script adds or removes content from a page it is updating the DOM tree
    - There are many reasons why you might want to respond to the DOM being updated, for example, you may want to notify the user that the page had changed

    | Event                         | Trigger                                                                                                         |
    |-------------------------------+-----------------------------------------------------------------------------------------------------------------|
    | ~DOMNodeInserted~             | Fires when a node is inserted into the DOM tree (e.g. ~appendChild()~, ~replaceChild()~, ~insertBefore()~)      |
    | ~DOMNodeRemoved~              | Fires when a node is removed from the DOM tree (e.g. ~removeChild~, ~replaceChild()~)                           |
    | ~DOMSubtreeModified~          | Fires when the DOM structure changes and it fires after the event ~DOMNodeInserted~ or ~DOMNodeRemoved~         |
    | ~DOMNodeInsertedIntoDocument~ | Fires when a node is inserted into the DOM tree as a descendant of another node that is already in the document |
    | ~DOMNodeRemovedFromDocument~  | Fires when a node is removed from the DOM tree as a descendant of another node that is already in the document  |

    - If your script makes a lot of changes to the DOM then it would cause a lot of mutation events firing making the page feel slow and unresponsive
    - The events can also trigger other event listeners as they propagate through DOM causing more DOM changes and thus more mutation events
    - Thus mutation events are deprecated and does not work reliably in modern browsers
    - Instead we now use mutation observers
    - Mutation observers are designed to wait until a script has finished its task before reacting then report the changes as a batch rather than one at a time
    - With mutation observers you can also specify the type of changes to the DOM that you want them to react to
    - All these properties are part of the event object (check out the questions to see how mutation observers work)
      
*** Section 6.7.7: HTML5 Events
    - There are page-level events that have been included in versions of the HTML5 spec that have become very popular quickly: ~DOMContentLoaded~, ~hashchange~, and ~beforeunload~
    - ~DOMContentLoaded~ is an event when the DOM tree is formed unlike ~load~ where it loads all HTML, CSS, scripts, etc
    - ~DOMContentLoaded~ is used with the ~document~ object because it is only concerned with the DOM which the root node is the ~document~ object
    - Unlike ~load~ is used with the ~window~ object because it needs to the context of the entire browser page, not just DOM
    - However, just like ~load~ can be added to both ~window~ and ~document~, ~DOMContentLoaded~ can also be added to ~window~ because the target element is the ~document~ object and it bubbles up to the ~window~ object
      
    | Event              | Trigger                                                                                                                                                                                                                                                                                                                                                                                                                     |
    |--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | ~DOMContentLoaded~ | Event fires when the DOM tree is formed (images, CSS, and JS might still be loading), thus scripts start to run earlier than using the ~load~ event which waits for other resources such as images and ads to load but because of this if there are other scripts that adds content to DOM the early script will not be able to see it                                                                                      |
    | ~hashchange~       | Event fires when the URL hash changes (without the entire window refreshing), recall that hashes are used on links to specific parts (sometimes known as anchors) within a page and also on pages that use AJAX to load content so ~hashchange~ event handler works on the ~window~ object and after firing, the event object will have ~oldURL~ and ~newURL~ properties that hold the url before and after the hash change |
    | ~beforeunload~     | Event fires on the window object before the page is unloaded, it should only be used to help the user and not to encourage them to stay on a website if they are trying to leave (e.g. tell the user some work has not been saved yet)                                                                                                                                                                                      |

    - Some things to note about ~beforeunload~, you can add a message to the dialog box that is shown by the browser but you do not have control over the text shown before the message you give or the buttons the user can press
    - Thus the browser will always show a pop-up message but there are ways to avoid the pop-up message if it is not required and you have an event listener attached to the event but for the most part modern browsers are restrictive with the event ~beforeunload~ and thus the only thing you can do is simply give it a prompt
    
*** Section 6.7.8: Where Events Occur
    - The event obect can tell you where the cursor was positioned when an event was triggered
    - The properties of the event ~screenX~ and ~screenY~ indicate the position of the cursor within the entire screen on your monitor measuring from top left corner of the screen rather than the browser
    - Thus ~screenX~ and ~screenY~ properties that give the position of the cursor relative to the monitor screen, *not* the page or the browser window, but the entire monitor even if the browser is minimized
    - ~pageX~ and ~pageY~ properties indicate the position of the cursor within / relative to the entire page even if the top of the page may be outside of the viewport so the coordinates of the cursor of ~screenX~ and ~screenY~ may be different than ~pageX~ and ~pageY~
    - ~clientX~ and ~clientY~ properties indicate the position of the cursor within the browser's viewport so if the top of the page is no longer in view it will not affect the client's coordinates
    - So ~screenX~ and ~screenY~ coordinates are relative to the entire monitor screen (even if the browser is minimized), ~pageX~ and ~pageY~ coordinates are relative to the entire page (even if the viewport only shows a fraction of the page), and ~clientX~ and ~clientY~ coordinates are relative to the viewport inside the browser window (even if the user scrolls but the cursor stays the same then the coordinates will stay the same)

** Section 6.8: Chapter Exercise
   - We are going to create a voice notes app
   - This app will allow the user to record voice notes
   - The user can enter the name of the note, press record, the record button will change to a stop button, and the user can then press stop to save it
   - Then the user will be able to go back listen to their notes, rename their note, or delete their note
   - Technical requirements:
     - As the user types, check if an existing note with that name already exists, if so display a message notifying the user to use a different name (use ~keyup~ event)
     - For the record / stop buttons use an attribute called ~data-state~ (learn more about custom ~data-*~ attributes) and at first it will have the value of ~record~ and then when it is pressed it will change to ~stop~
     - You can use a CSS rule depending on the value of ~data-state~ to change the appearance of the button (record icon or stop icon)
     - Then when the button is clicked, you can see the current value of ~data-state~ and do some work depending on if it needs to record or stop
     - Create a table with saved notes and provide 3 options, play, rename, and delete (use event delegation to determine which row was clicked on)
   - [[file:./006.008.Chapter_Exercise/index.html][Here is my chapter exercise]]

** Section 6.9: Summary
   - Events are the browser's way of indicating when something has happened such as when a page has finished loading or a button has been clicked
   - Binding is the process of stating which event you are waiting to happen and which element you are waiting for that event to happen upon
   - When an event occurs on an element, it can trigger a JavaScript function and when this function then changes the web page in some way it feels interactive because it has responded to the user
   - Event delegation is used to monitor the events that happen on all of the children of the element
   - Most commonly used events are the W3C DOM events but there are also HTML5 spec events and browser-specific events
   
    
* Keywords
| Term                                                        | Definition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Events                                                      | Events are actions that occur in the browser, the browser fires an event when an action occurs and in JS the event is handled to trigger some code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Event Handlers                                              | Event handlers are functions that are trigged or invoked to specific events when these events occur, you cannot have more than one function to respond to an event                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Event Listeners                                             | Event listeners "listen" to when an event is fired and responds to that event by triggering some code, it "listens" because there could be multiple event listeners to a single event in a single element                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Mutation Events                                             | Mutation events are events that occured whenever DOM would have some change, these events could have event listeners but this would cause poor performance because the event will constantly be fired since the DOM is constantly changing today in age of interactive websites                                                                                                                                                                                                                                                                                                                                                                            |
| Mutation Observers                                          | Mutation observers is an API that allows to "observe" changes to the DOM and instead of responding to each change one-by-one, mutation observers will only fire after changes are batched thus causing it to be more efficient when trying to respond to DOM changes                                                                                                                                                                                                                                                                                                                                                                                       |
| Event Flow                                                  | Event flow describes the order in which events are received by elements in the DOM when an event occurs, in other words, an element triggers an event how does the event propagate, does it start at the originating element or somewhere else                                                                                                                                                                                                                                                                                                                                                                                                             |
| Event Bubbling                                              | Event bubbling is an event flow that starts at the originating element (the element that caused the event to fire) and then "bubbles up" to its parents, ancestors, and eventually the root of the web page the ~winodw~ object (starts at originating element and ends at ~window~ element)                                                                                                                                                                                                                                                                                                                                                               |
| Event Capturing                                             | Event capturing is an event flow that instead of starting at the originating element, it actually starts at the top of web page (the ~window~ object) and travels down toward the originating element (starts at ~window~ and ends at the originating element)                                                                                                                                                                                                                                                                                                                                                                                             |
| Event Delegation                                            | Event delegation takes advantage of the event flow (bubbling or capturing, but most common in bubbling) and attaches a single event listener to an ancestor element so that this single event listener handles all of the events for its children, grandchildren or any descendant (this way we have one event listener managing multiple elements instead of multiple elements handling one listener)                                                                                                                                                                                                                                                     |
| W3C (World Wide Web Consortium)                             | W3C is the main international standards organization for the web, W3C sets standards and ensures compatibility, originally it handled HTML, CSS, DOM, etc. but now it focuses on the border web techology such as CSS, accessibility, web apis, semantic web, XML, SVG, etc. and has left HTML and DOM specs to WHATWG                                                                                                                                                                                                                                                                                                                                     |
| WHATWG (Web HyperText Application Technology Working Group) | WHATWG organization was formed from the major browser vendors because they wanted to continue to improve HTML instead of trying to move towards XML (e.g. XHTML) and since then W3C and WHATWG have been developing different HTML specs but since 2019 both organizations agreed to use the HTML specs by WHATWG so instead of having "versions" of HTML we have an always evolving "living standard" of HTML and now WHATWG is in charge of HTML specifications, the DOM, web forms, events, parsing rules, etc. making specifications of how web pages should behave in real-world browsers (so W3C does not handle DOM or HTML specifications anymore) |

* Questions
  - *Q*: If you have no event handler in JS, are events still fired (but does not trigger any code)?
         - Yes events are still fired even if there are no event handlers attached
	 - The events are part of the browser's system and will fire events when needed but if there are no event handlers it will simply not trigger any code
	 - This is important because although you may not use event handlers some 3rd party library may have some event handlers to respond to some events
	 - Regardless events are always fired no matter if there are event handlers or not

  - *Q*: What does the mutation events actually do like ~DOMSubtreeModified~, ~DOMNodeInserted~, ~DOMNodeRemoved~, ~DOMNodeInsertedIntoDocument~, and ~DOMNodeRemovedFromDocument~?
         - These events are now deprecated and should not be used
	 - These events fire synchronously (one by one) and fire very frequently often resulting in severe performance problems
	 - Instead we use ~MutationObserver~ which handle changes in batches,it is more efficient and asynchronous thus providing better control
	 - Nevertheless, I've go over these events
	 - ~DOMSubtreeModified~ can be attached to any element and is fired when any changes are made to the subtree of the element node (insertion, removal, text / content cahnges, etc.)
	 - Thus ~DOMSubtreeModified~ will fire the event with any kind of DOM change below the element node (the element does *not* need to be in the DOM tree for it to work)
	 - ~DOMNodeInserted~ can be attached to any element and it is fired when a node is inserted below the element node
	 - ~DOMNodeInserted~ does not care if the element node's subtree is already in DOM or not, it will simply fire an event when a descendant is added to the element
	 - ~DOMNodeRemoved~ can be attached to any element and it is fired when a node is removed below the element node (it does not care if the element is in the DOM or not)
	 - ~DOMNodeInsertedIntoDocument~ can be attached to the ~document~ object and is fired when a node is added to the document and becomes part of the main DOM tree so it will only fire you append a child to an existing element in the DOM tree
	 - ~DOMNodeRemovedFromDocument~ can be attached to the ~document~ object and is fired when a node is removed from the main document tree and will only fire when you remove a child of an already existing element in the DOM tree

  - *Q*: What is the difference between DOM event handlers and DOM event listeners?
         - Event handlers are element *properties* that are named as the event name preceded by the word "on"
	 - You can then use this DOM element and assign it a named function to it directly (without any parentheses)
	 - So whenever the event is fired, the event will be the one invoking the function
	 - With event handlers you can only have one handler per event type (one for ~onclick~, one for ~onmouseover~, etc.) and if you assign multiple event handlers it may overwrite previous ones or cause unexpected behavior
	 - Event listeners are added by using the *method* ~addEventListener()~
	 - So whenever the event is fired you can use a named function or an anonymous function to fire in response
	 - The benefits of listeners is that you can have multiple listeners for one event in a single element, it supports bubbling and capturing, you can remove it using ~removeEventListener()~, and it is a more modern and flexible API
	 - Thus the recommended approach is to use event listeners

  - *Q*: If two scripts on the same page handle the same event, which code is run first?
         - It depends on which script is imported first
	 - If there are two scripts that assign event handlers using the properties and if unexpected behavior does not happen then the last assignment will be the one that will run because it overwrites the previous assignment
	 - If two event listeners are added the listeners are called in the order they were added so if script A is run before script B then the listener in script A will run first
	 - If you have one event handler and one event listener then the event listeners do not affect the event handlers and vice versa so the one that will run first depends on which event handler or listener appears first

  - *Q*: Can you pass function arguments to event handlers or event listeners?
         - No, you cannot directly pass arguments to event handlers or listeners
	 - Event handlers only accept the function name and cannot accept arguments because that would mean you are invoking the function
	 - Plus the event is the one calling the function, how does it know what arguments to pass to the function?
	 - Event listeners is the same thing, you cannot pass a named function with arguments because that would mean you are invoking the function
	 - Instead with event listeners you create an anonymous function and inside the anonymous function you call the function with the arguments that you want
	 - Most of the time you can use variables outside the anonymous function as long as it is in scope and that is one way to add arguments to your event listeners
	 - However, there is no direct way to pass arguments to event handlers or event listeners

  - *Q*: How can I pass arguments from outside the event listener into the event listener function?
         - You create an anonymous function and you call the named function within the anonymous function
	 - Inside the anonymous function you can create variables to pass along as arguments to the anonymous function
	 - If you need variables from outside the anonymous function then you may use those variables as well as long as it is in scope

  - *Q*: How does capturing and bubbling work in focus and blur events?
         - ~focus~ and ~blur~ events do not bubble but they do capture (it is just not a bubbling event)
	 - So if you were to use ~focus~ and ~blur~, you would have to add the events directly on the originating element (unless you use capture event flow), otherwise if you do it in a parent it will not be called (unless for capture event flow)
	 - If you want the focus or blur event to propagate either upward or downward, you would have to use their counterpart events called ~focusin~ and ~blurin~
	 - ~focusin~ and ~blurin~ can bubble or capture depending on what you give as the 3rd argument in ~addEventListener()~
	 - In summary, ~focus~ and ~blur~ events do not bubble but they do capture so you have to add the event directly on the originating element or use capture on the parent elements, otherwise you can use their counterparts ~focusin~ and ~blurin~ if you'd like an event flow

  - *Q*: How does mutation observers work?
         - Mutation observers are replacing mutation events because observers get a batch of mutations instead of responding to each one thus there is fewer callbacks and improving performance
	 - The way it is works is by creating a ~MutationObserver~ object
	 - This mutation observer will be given a function, this function will run whenever the batch of mutations is received
	 - This function will receive two arguments: one a list of all the changes that has happend and another one for the observer object
	 - Inside this function you can do some work using the list of all the changes or all the mutations (e.g. one might be a child added, an attribute added, etc.) and the observer object
	 - You get this function and pass it to the constructor of the ~MutationObserver~ object or you can create an anonymous function direclty inside the argument space of the constructor
	 - Then you simply use the mutation observer object and call the method ~observe~ this method will accept two arguments one for the element node in which you want to start observing mutation changes and the other are the options of what you want to observe
	 - The options is a object with key-value pairs (e.g. ~{attributes: true, childList: true}~) and this specifies which DOM mutations should be reported to the mutation observer's callback (given in the constructor)
	 - At the minimum the options must have ~childList~, ~attributes~, and / or ~characterData~ otherwise a ~TypeError~ exception will be thrown
	 - You can always stop observing by calling ~observer.disconnect()~
	 - Thus mutation observers peform better and give you more control compared to mutation events

  - *Q*: What is the difference between events ~load~ and ~DOMContentLoaded~?
         - Both events deal with the paging loading
	 - ~load~ is an event that is fired when the entire page loads including images, CSS, ~iframes~, and all dependent resources
	 - ~DOMContentLoaded~ is an event that is fired when only the DOM has been loaded and it does not need to wait for other dependent resources like CSS
	 - ~load~ is an event registered with the ~window~ object while ~DOMContentLoaded~ is registered with the ~document~ object
	 - If you need to trigger an event for the entire page is loaded including all resources (e.g. CSS) then use ~load~
	 - If you only want an event to trigger when the DOM is finished loading then use ~DOMContentLoaded~
	 - If you are only concerned with getting elements by id so you have to wait for DOM to be finished loading then use ~DOMContentLoaded~
	 - In the end, ~load~ waits for the entire page to load including all resources while ~DOMContentLoaded~ waits for only DOM to be finished loading

  - *Q*: What are custom ~data-*~ HTML attributes?
         - Custom ~data-*~ attributes in HTML are a way to embed custom, private data inside HTML elements, data that you can access and manipulate with JS
	 - These are HTML attributes that begin with ~data-~ followed by a name of your choosing
	 - These attributes are ignored by the browser's default rendering but are accessible via JS making them useful for storing extra data tied to an element without polluting other attributes or using hidden inputs
	 - Thus you can store metadata in these attributes for each element
	 - To get the attribute in JS, you can use ~getAttribute()~ or you can use the ~dataset~ property followed by another property and the name of this property is the name of the attribute after ~data-~
	 - Dashes after ~data-~ are converted into camel case so you can access the attributes in JS by first using the ~dataset~ property and then get the property of the ~dataset~ which is named like the attribute after ~data-~
	 - In summary, ~data-*~ are custom HTML attributes that can be used as any metadata attribute, the browser does not render the attributes and ignores the attributes, and you can access the attribute through the ~dataset~ property by using the property named just like the attribute after ~data-~

  - *Q*: What happens if you specify event bubbling in one script and event capturing in another script for the same event in the same element?
         - Both event listeners will run but the first one that will run will be the capturing event flow listener and then the bubbling event flow listener
	 - Here is the order of event propagation when events have different event flows
	 - It always starts with the capturing phase
	   - The event moves from the root (~window~ -> ~document~, etc.) down to the target element
	   - Only the listeners with ~capture: true~ are triggered and run
	 - Eventually, it reaches the target element (originating element)
	   - If the target element has multiple listeners with different event flows then it will first run the capture-phase listeners on the target
	   - Then it will run the bubble-phase listeners on the target
	 - After the target element's listeners are run, it then starts the bubbling phase
	   - The event bubbles from the target back up to the root and only listeners added with ~capture: false~ (or no argument) are triggered
	 - This event phases always happen, it is first capturing phase, then target element, then bubbling phase (capture -> target element -> bubble)
	 - Keep in mind there are some events that do not bubble, for example ~focus~, ~blur~, ~load~ and ~mouseenter~, so the event phases for these elements do not use bubble
	 - However, for the majority of events, many of them follow the same phases: capture -> target element -> bubble
	 - Also keep in mind the method ~stopProgapation()~, if the method is called in the capture phase then it will stop it right there and the bubbling phase will never be called after the invoked method because bubbling is after capturing
	 - In summary, all events follow the same event phase: capture -> target element -> bubble (however there are some events that do not bubble and ~stopProgapation()~ will stop this flow at whatever point it is called)

  - *Q*: What is the difference between W3C DOM specs and HTML5 specs?
         - This question is a bit erroneous because W3C specs included HTML5 specs since W3C specs released HTML versions and their specs like HTML5
	 - What happened was in the early 2000s WHATWG was formed by the major browser vendors due to the frustration of W3C specs, so they started to make their specifications in parallel to W3C
	 - Eventually, many browsers started to follow WHATWG HTML specs instead and in 2019 both organizations agreed, W3C will no longer handle HTML or DOM specs, it will follow the specs from WHATWG
	 - So now WHATWG handles HTML and DOM specs and they contain a "living-standard" so they don't release versions because it is constantly changing (a different philosophy from W3C)
	 - So in today's age there are no longer differing specs and discrepancies between specs because HTML and DOM are handled by one organization which encourages for standardization for useful features

* Summary
  - Browsers registers and fires different types of events such as a click, hover, when content is loaded, and more, each event will have a reason it fires
  - When events happen in the browser it is said these events were fired or raised by the browser
  - It is up to JavaScript and the scripts to handle that event raised and trigger some code by calling some function
  - Events will be raised regardless if the scripts handles the events or not, the only difference will be does JS want to do something with the event or not
  - There are many events some fall under UI events (when content is loaded), keyboard events (when user presses key), mouse events (when user clicks), form events (when user submits form), and mutation events (when a node has been added to DOM)
  - In order to handle an event and trigger some code you first get the element you want event listener to go onto, you then bind the event or specify which event you want to trigger the code, and then you specify the code you want to run by either a named function or an anonymous function
  - There are 3 ways to add event handlers, the first way is to add an attribute to HTML elements with the event name preceded by the word "on" and giving it a named function but this is bad practice and no longer recommended (this is normally called HTML Event Handlers)
  - The second way is to use "event handlers" in JS, this is done by first getting the element you want to add an event handler and then access it's property using the event name preceded by the word "on" then you simply assign it using the assignment operator a named function without parentheses (the drawback is that this event for that elements can only have one function if there are multiple functions then unexpected beahvior will occur)
  - The third and recommended way is to use event listeners, you get the element of interest, then you use the method ~addEventListener()~, you specify the event name that you want to listener to, the function (named or anonymous), and the event flow, this is the recommended approach because you can multiple listeners listening and waiting to respond to the same event on the same element
  - Not relevent anymore but in IE5 to IE8 instead of using ~addEventListener()~ it would use ~attachEvent()~ which does the same thing but the event name needs tp preceded by the word "on" in IE5-8 so always check if ~addEventListener()~ is supported if you are going to work with IE for whatever reason
  - Triggered events can propagate from the targeted element all the way to its greatest ancestor (the document object), what does that mean?
  - So this is event flow, events flow from either the target element (the element that triggered the event) to its ancestors or it flows from its ancestors first then flows downwards to it the originating element
  - When it flows from originating element to greatest ancestor it is called event bubbling because it "bubbles" up and this is the default behavior for most listeners but when the event flows from its greatest ancestor to the originating element it is called event capturing
  - By default many listeners use event bubbling and you can specify the event flow in ~addEventListener()~, if the 3rd argument is false then it will use event bubbling and if it is true then it will use event capturing, there are some events that may not use either flow like ~focus~ but they provide events such as ~focusin~ if you'd like ~focus~ to follow some type of event flow
  - Every time an event fires, the ~event~ object is passed as a parameter to the named function or anonymous function and this event object contains helpful data such as which element was the originating element, which key was pressed for keyboard events, and other useful information but if you are using IE5-IE8 (which I doubt) you need to get the event object from the ~window~ object and some methods and properties may be different
  - You may have multiple elements of which you would like to add event listeners but having many event listeners can cause your page to be slow so instead we use something called event delegation
  - Event delegation is having one event listener for all of its children, so whenever a child triggers an event, the ancestor will handle the event listener because the event will flow upwards or downwards but eventually pass by that ancestor, and the ancestor will figure out which child triggered the event and do some work based on that information
  - Event delegation can have you write less code, make your code more organized, and make your page faster
  - The key part of event delegation is to figure out which element raised the event and you can do this by using the event object passed into the function, you can access the originating element by using the property ~event.target~ (or ~event.srcElement~ in IE5-8)
  - You can also use ~this~ since when you call a function ~this~ will refer to the owner of the function (who called that function) but it won't work for event delegation or anonymous functions because the owner of the function would be the element that the event listener is on not the originating element or in the case of the anonymous function the owner would be the anonymous function
  - The event object has a lot of properties and methods, some methods include ~preventDefault()~ which prevent the default behavior of some elements like the submit form or link taking you to another page and ~stopPropagation()~ will stop the event from propagating upward (bubbling) or stop propagating downward (capturing), thus it would stop there where it encounters ~stopPropagation()~ (IE5-8 use ~returnValue~ and ~cancelBubble~ properties instead of the methods shown)
  - In the end there are a lot of different types of events specified in the W3C DOM specs, HTML5 specs, and generally accepted BOM events but now in the modern age when something useful and new emerges there is a push for standardization so many of the events discussed are already placed into W3C specs or HTML5 specs
  - There are UI events (~load~, ~unload~, etc.), focus and blur events, mouse events, keyboard events, form events, mutation events & observers (mutation events are deprecated and no longer used instead use mutation observers), HTML5 events that were added as part of HTML5, and the event object has properties to determine the coordinates of your mouse when the event was triggered relative to the monitor screen, relative to the entire web page, and relative to the user's browser's viewport
