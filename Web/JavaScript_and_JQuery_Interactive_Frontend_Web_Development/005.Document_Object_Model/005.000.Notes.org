#+title: Chapter 5: Document Object Model
#+author: Alfredo Mejia
#+options: num:nil html-postamble:nil
#+html_head: <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css" /> <style>body {margin: 5%} h1,h2,h3,h4,h5,h6 {margin-top: 3%} .content ul:not(:first-child) {margin-top: 0.25em}}</style>

* Navigation
| Nav   | Title                                                       | Links                                   |
|-------+-------------------------------------------------------------+-----------------------------------------|
| Index | Notes Home                                                  | \vert [[file:../../../index.html][html]] \vert [[file:../../../index.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main][github]] \vert |
| Home  | JavaScript & JQuery - Interactive Front-end Web Development | \vert [[file:../000.Home.html][html]] \vert [[file:../000.Home.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development][github]] \vert |
| Prev  | Chapter 4: Decisions & Loops                                | \vert [[file:../004.Decisions_and_Loops/004.000.Notes.html][html]] \vert [[file:../004.Decisions_and_Loops/004.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/004.Decisions_and_Loops][github]] \vert |
| Next  | Chapter 6: Events                                           | \vert [[file:../006.Events/006.000.Notes.html][html]] \vert [[file:../006.Events/006.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/006.Events][github]] \vert |

* Notes

** Section 5.1: Introduction
   - The Document Object Model (DOM) specifies how browsers should create a model of an HTML page and how JavaScript can access and update the contents of a web page while it is in the browser window
   - The DOM is neither part of HTML nor poart of JavaScript instead it is a separate set of rules that is implemented by all major browsers and covers two areas: making a model of the HTML page and accessing and changing the HTML page
   - When the browser loads a web page it creates a model of the page in memory and DOM specifies the way in which the browser should structure this model using a DOM tree
   - DOM is called an object model because the model (the DOM tree) is a made of objects and each object represents a different part of the page loaded in the browser window
   - DOM also defines methods and properties to access and update each object in the DOM tree which in turn updates what the user sees in the browser
   - DOM is sometimes referred to as an application programming interface (API)
   - Using the API your script can ask the browser about the current page and how to tell the browser to update what is being shown to the user

** Section 5.2: DOM Tree
   - As a browser loads a web page, it creates a model of that page and the model is called a DOM tree
   - The DOM tree is stored in the browsers' memory and it consists of four main types of nodes:
     - Document node (root node)
     - Element nodes (e.g. h1, h2, li, ul, etc.)
     - Attribute nodes (e.g. attribute belonging to h1)
     - Text nodes (text within the element)
   - Every element, attribute, and piece of text in HTML is represented by its own DOM node
   - The root of the tree is the document node and it represents the entire page
   - The root node is the document node which is the document object we have discussed in previous chapters
   - Let's take the following HTML:

   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
	 <title>Example</title>
       </head>
       <body>
	 <h1 id="heading">Heading</h1>
       </body>
     </html>
   #+END_SRC

   - The example above will produce a tree like the following:

   #+BEGIN_SRC text
     document
     |- html
     |  |- head
     |  |  |- text: "\n"
     |  |  |- title
     |  |     |- text: "Example"
     |  |  |- text: "\n"
     |  |- text: "\n"
     |  |- body
     |  |  |- text: "\n"
     |  |  |- h1
     |  |     |- attribute: id
     |  |     |- text: "Heading"
     |  |  |- "text: "\n" 
   #+END_SRC

   - Notice the root of the dom tree is the document object
   - *Every tree node is an object even the leaf nodes*
   - The root node is the document object
   - Then we have the element nodes which are element objects (objects that use the ~Element~ interface)
   - Then we have the text nodes which are text objects (objects that use the ~Text~ interface)
   - The fourth node are the attribute nodes which are attribute objects (objects that use the ~Attr~ interface)
   - These are the main 4 nodes in a DOM tree but there are 11 types of nodes in the DOM tree:
     1. Document Node
     2. Element Node
     3. Attribute Node
     4. Text Node
     5. CDATA Section Node
     6. Entity Reference Node
     7. Entity Node
     8. Processing Instruction Node
     9. Comment Node
     10. Document Type Node
     11. Document Fragment Node
   - There are some things to note however
   - Typically the leaf nodes include text nodes, comment nodes, and CDATA section nodes
   - Attribute nodes are *not* considered leaf nodes because attribute nodes are *not* considered to be part of the main DOM tree hierarchy like element or text nodes
   - Instead attribute nodes are "associated" with element nodes and held separately as part of the element's "NamedNodeMap"
   - The DOM tree represents parent-child relationships and attribute nodes are properties of elements, thus attributes are not children of the elements but properties (attributes) that exist on the element node
   - This is why attributes will not appear in the ~childNodes~ of an element and you can access the attributes using the element's property called ~attributes~
   - Another thing to note is that spaces and newlines are valid characters and become part of the DOM tree
   - Any character including whitespace, newlines, tabs, etc. that are inside an element will be part of the DOM tree as text objects under the element node as shown in the example above
   - There are only two exceptions and that is whitespace characters before the element ~<head>~ are ignored and white space after the closing body tag (~</body>~) are automatically moved inside the body
   - Other than those exceptions every whitespace characters are placed into the DOM tree as text objects

   - Going back to the main nodes, the document node is the starting point for all visits to the DOM tree so when you access any element, attribute or text node you navigate to that node via the ~document~ node
   - HTML elements describe the structure of an HTML page so to access the DOM tree you start by looking for elements (via the document node) and once you find the element you want then you can access its text and attribute nodes
   - Thus you go from document node then you use some methods to find the element nodes and then you use methods / properties to find the text and attributes of the element you want to modify
   - HTML elements can carry attributes and these are represented by the attribute nodes in the DOM tree
   - Attribute nodes are *not* children of the element that carries them instead they *are part* of that element
   - Once you access an element there are specific JavaScript methods and properties to read or change that element's attributes
   - Once you have accessed an element node, you can can then reach the text within that element and this is stored in its own text node
   - Text nodes cannot have children and thus text nodes are leaf nodes
   - So if an element contains a text node *and* another child element, the other child element is *not* a child of the text node but rather a sibling of the text node and a child of the containing element
   - Thus relationships between the ~document~ and all of the element nodes are described using the same terms as a family tree: parents, children, siblings, ancestors, and descendents (so every node is technically a descendant of the ~document~ node)
   - Finally, each node is an object with methods and properties so scripts can access and update the DOM tree (not the source HTML file) but the DOM tree structure and any changes made to the DOM tree are reflected in the browser

** Section 5.3: Working with the DOM Tree
   - Accessing and updating the DOM tree involves two steps:
     1. Locate the node that represents the element you want to work with
     2. Use its text content, child elements, and attributes

*** Section 5.3.1: Locating / Retrieving the Elements
    - There two common ways to locate or retrieve an element using DOM: DOM queries or traversing the DOM
    - Methods that find elements in the DOM tree are called DOM queries
    - For example, to select an individual element node, the most common methods are:
      - ~getElementByID(<id>)~: uses the value of an element's ~id~ attribute
      - ~querySelector(<selectors>)~: uses a CSS selector or group of CSS selectors and returns the first matching element
    - Common methods to select multiple elements are:
      - ~getElementsByClassName(<names>)~: selects all elements that have all of the given class names
      - ~getElementsByTagName(<names>)~: selects all elements that have the specified tag name
      - ~querySelectorAll(<selectors>)~: uses a CSS selector or group of CSS selectors to select all matching elements
    - These methods are commonly referred to as DOM queries because you query DOM to retrieve elements
    - Another way to retrieve elements is by traversing the DOM
    - Since the DOM is represented by a tree it can be traversed through the parents, children, and siblings
    - To traverse the DOM tree you need to have access to at least one element
    - For example, we all have access to the ~document~ element so we can use the property ~document.firstChild~ or ~document.lastChild~ to traverse the tree and get another element
    - You can then use continue to traverse until you receive a null value for example ~document.lastChild.lastChild.lastChild~ will return a valid element if it exists
    - So every element has the following properties which reference other elements and they are:
      - ~<elem>.parentNode~: selects the parent of the current element node (will return just one element)
      - ~<elem>.previousSibling~ or ~<elem>.nextSibling~: selects the previous or next sibling from the DOM tree
      - ~<elem>.firstChild~ or ~<elem>.lastChild~: Select the first or last child of current element
    - All of these elements can be stored in a variable so whenever you use a property or a method (DOM query), you can use a variable to store the element and use the element later via the variable created
    - Once you have the element in a variable you can work with that node, its parent, or any children without needing to find or retrieve that element again
    - The way the variable store the element is by storing a reference to the location of the element in the DOM tree so it can easily access the element without needing to find it again
    - Storing an element in a variable is called caching the selection because instead of having the browser find the element it will use the variable as a form of "cache"
    - Finding the quickest way to access an element within your web page will make the page seem faster and / or more responsive thus evaluating the minimum number of nodes on the way to the element you want to work with is best for a faster and more responsive web page
    - Usually ~getElementById()~ may be the fastest way to get to a single element since no two elements on the same page shuld have the same value for an ~id~ attribute but not all elements have the ~id~ attribute so we have to use what we can to get the fastest or shortest route to our element of interest
      
**** Section 5.3.1.1: Selecting Individual Elements
     - DOM queries may return one element, or they may return a ~NodeList~ which is a collection of nodes
     - Sometimes we would like to select one element or a group of elements (e.g. all ~<h1>~ elements)
     - Methods that return a single element node:

     | Method                          | Description                                                                                                                         |
     |---------------------------------+-------------------------------------------------------------------------------------------------------------------------------------|
     | ~getElementById('id')~          | Selects an individual element given the value of its ~id~ attribute                                                                 |
     | ~querySelector('css selector')~ | Uses CSS selector syntax that would select one or more elements but this method will only return the first of the matching elements |

     - ~getElementById()~ and ~querySelector()~ can both search an entire document and return individual elements (both use a similar syntax)
     - ~getElementById()~ is the quickest and most efficient way to access an element because no two elements can share the same value for their ~id~ attribute
     - ~getElementById()~ allows you to select a single element node by specifying the value of its ~id~ attribute
     - ~getElementById()~ has one parameter: the value of the ~id~ attribute on the element you want to select which is placed inside quotation marks because it is a string
     - ~querySelector()~ is a more flexible because its parameter is a CSS selector which means it can be used to accurately target many more elements but returns the first node of the matching elements

**** Section 5.3.1.2: Selecting Multiple Elements
     - If a method /can/ return more than one node then it will always return a ~NodeList~ which is a collection of nodes (even if it only finds one matching element)
     - You then can either iterate through the list or select the element you want from the list using an index number (recall the index number always start at zero)
     - Methods that return one or more elements as a ~NodeList~

     | Method                             | Description                                                                                                            |
     |------------------------------------+------------------------------------------------------------------------------------------------------------------------|
     | ~getElementsByClassName('class')~  | Selects one or more elements given the value of their class attribute (this method is faster than ~querySelectorAll()~ |
     | ~getElementsByTagName('tagName')~  | Selects all elements on the page with the specified tag name (this method is faster than ~querySelectorAll()~          |
     | ~querySelectorAll('css selector')~ | Uses CSS selector syntax to select one or more elements and returns all of those that match                            |

     - A ~NodeList~ is a collection of element nodes and each node has an index number (starting at zero)
     - The order in which the element nodes are stored in a ~NodeList~ is the same order that they appear in the HTML page
     - When a DOM query returns a ~NodeList~ you may want to select one element from the list or loop through each item in the list and perform some statements on the elements
     - Although ~NodeList~ may have similar characteristics like an array, it is *not* an actual array, instead they are a type of object called a collection
     - ~NodeList~ has properties and methods such as ~.length~ (specifies the amount of items in the list) and ~.item()~ which returns a specific node from the list when you tell it the index number of item that you want
     - You can also use square brackets with the list to retrieve an item just like an array
     - You can store the object reference to the ~NodeList~ in a variable to work with the same selection of elements several times rather than collecting the same elements again
     - There are type "types" of ~NodeList~ you can use, either "live" ~NodeList~ or "static" ~NodeList~
     - Live ~NodeList~ are lists that are automatically updated when the DOM changes, for example, let's say we get all the items with the class "item" and later the DOM changes because we changed a node to have the class "item" the list will be automatically updated to reflect the DOM changes so it will include the new item we just added
     - So live ~NodeList~ reflect the changes of DOM if items have been added or removed from the list without needing to do any work because it happens automatically
     - The methods beginning with ~getElementsBy...~ return live ~NodeList~ and are typically faster to generate than static ~NodeList~
     - Static ~NodeList~ does not update the list automatically when the DOM changes thus whenever a new item is added or removed that is under your search criteria, you will have to re-query the DOM tree to get an updated list
     - If you do not re-query then the static ~NodeList~ will have the old unchanged list, it will not update or change to reflect the changes of DOM
     - The methods that begin ~querySelector...~ which use CSS selector syntax return static ~NodeList~ as they reflect the document when the query was made

***** Section 5.3.1.2.1: Selecting Elements Using Class Attributes
      - ~getElementsByClassName()~ method allows you to select elements whose class attribute contains a specific value
      - The method has one parameter: the class name which is given in quotes within the parentheses after the method name
      - This method always returns a ~NodeList~
      - The value of a class attribute can contain several class names each separated by a space but the method will try to find the class specified in the method within those class names separated by space
      - For example, let's say we have a class attribute with the value "style1 style2 style3" then if you were to specify to the method ~getElementsByClassName()~ "style1" then it will still retrieve it, "style2" will retrieve it as well, "style1 style2" will retrieve it as well, and even "style1 style3" will retrieve it as well
      - Why does the example above work? Take for example the argument "style1 style3" it is checking for elements that contain the class name "style1" and the elements that contain "style3" the order does not matter and each class name separated by a space are treated separate and individual class names just because an element has multiple class names does not mean that is their class names instead they have multiple class names
      - In other words, each class name are separated and individual class names which an element may be part of multiple class names and when you specify an argument in the method ~getElementsByClassName~ you are also treating the space separated class names as individual class names
	
***** Section 5.3.1.2.2: Selecting Elements By Tag Name
      - The ~getElementsByTagName()~ method allows you to select elements using their tag name
      - The element name is spceified as a parameter so it is placed inside the parentheses and is contained by quotation marks
      - Note that you do not include the angled brackets that surround the tag name in the HTML just the letters inside the brackets

***** Section 5.3.1.2.3: Selecting Elements Using CSS Selectors
      - ~querySelector()~ returns the first element node that matches the CSS-style selector
      - ~querySelectorAll()~ returns a ~NodeList~ of all of the elements that matches the CSS-style selector
      - Both methods take a CSS selector as their only parameter and the CSS selector syntax offers more flexibility and accuracy when selecting an element than just specifying a calss name or a tag name
      - JS code runs one line at a time and statements affect the content of a page as the interpreter processes them
      - So if a DOM query runs when a page loads and there are some statements that can affect the elements then rerunning the same query could return different set of elements because the elements were changed / modified

***** Section 5.3.1.2.3: Using the ~NodeList~
      - To select an element from a ~NodeList~ you can item use the ~item()~ method or the array syntax: both require the index number of the element you want
      - The ~item()~ method returns an individual node from the ~NodeList~ by specifying the index number of the element you want as a parameter of the method
      - You can use the ~length~ property of the ~NodeList~ to tell you how many items are in the ~NodeList~
      - Array syntax is preferred over the ~item()~ method because it is faster
      - You can access individual nodes using a square bracket syntax similar to that used to access individual items from an array by specifying the index number of the element you want inside the square brackets
      - Store the ~NodeList~ in a variable if you repeatedly use the ~NodeList~
      - When you have a ~NodeList~ you can loop through each node in the collection and apply the same statements to each
      - You can loops (for-loops are more adequate for ~NodeList~) to iterate through the loops and apply some statements to each item

**** Section 5.3.1.3: Traversing the DOM
     - When you have an element node you can select another element in relation to it using these five properties (this is known as traversing the DOM):
       - ~parentNode~: Finds the element node for the containing or parent element of the current node (e.g. you have a ~<li>~ node then the parent node could be ~<ol>~ or ~<ul>~)
       - ~previousSibling~ / ~nextSibling~: Finds the previous or next siblings element nodes of the current node (e.g. you have a ~<li>~ then the siblings nodes could be other ~<li>~ that came before or after the current ~<li>~ node)
       - ~firstChild~ / ~lastChild~: Find the first or last child node of the currrent node (e.g. you have a ~<ul>~ then the children nodes, first or last, could be ~<li>~ nodes)
     - These are properties of the current node not methods to select an element therfore they do not end in parentheses
     - If you use these properties and they do not have a previous sibling, next sibling, first child, or last child then the result will be ~null~
     - These properties are *read-only* they can only be used to select a new node but you *cannot* update the parent, sibling, or child (you will need to use other methods to change the DOM tree)
     - Traversing the DOM can be difficult because some browsers add a text node whenever they come across whitespace between elements
     - Whitespace between elements are treated as text nodes so the properties (~previousSibling~, ~nextSibling~, ~firstChild~, and ~lastChild~) can return different elements depending on the browser and how it treats whitespace
     - Thus text nodes are created for whitespace characters and added to the DOM tree
     - You could take out all the whitespace from your HTML page and it will technically be smaller and faster (because no text nodes) but it will make the code much harder to read
     - Another solution is to avoid using the properties ~previousSibling~, ~nextSibling~, ~firstChild~, and ~lastChild~ to avoid any possible unexpected behavior and instead use a JS library such as jQuery which helps deal with such problems
     - Some browsers may or may not create text nodes for whitespaces so it all depends on the browsers' implementation thus the properties may be pointing you may not expect and thus it is best to avoid using these properties
     - However, almost all modern browsers create text nodes for whitespaces
     - The only time it is safe to use these properties (~previousSibling~, ~nextSibling~, ~firstChild~, and ~lastChild~) is if there are no whitespace or if you know your web page will only be run in browsers that treat whitespace as text nodes
       
*** Section 5.3.2: Use / Update the Elements
    - Text inside any element is stored inside a text node
    - Recall that if text exist within an element, the element will have one or multiple text nodes as children in the DOM tree
    - How can you access the text nodes?
    - There isn't a method or property that retrieves the text nodes or the child text nodes instead you use the properties that traverse the DOM tree such as ~.firstChild~ or ~.lastChild~ or you can use the property ~.childNodes~ which returns a ~NodeList~ which is a list with all the child nodes
    - Then you can determine the type of node by using ~.nodeType~ and filter based on the text node
    - An element may have multiple text nodes
    - So to access the text node, you first retrieve an element (other than the text node) and you use one of their properties to retrieve their child text node (using ~.firstChild~, ~.lastChild~, or ~.childNodes~)
    - Recall that the text nodes are leaf nodes and do not have any children
    - Once you have access to the text node, then you can use the text node's *only* property ~.nodeValue~ to get the text from the element
    - The property ~.nodeValue~ is only useful and meaningful to a few nodes such as text nodes (stores text content), comment nodes (stores comment text), attribute nodes (stores attribute values), and CDATA section nodes (stores CDATA content)
    - The property ~.nodeValue~ for the other nodes is null
    - You can use the property ~.nodeValue~ to update, use, or change the text contents of the text node within the parent element, for example, if the text content says "hello" you can change it by overriding the content to "bye"
    - Thus the ~.nodeValue~ lets you access or update contents of a text node and recall that if the parent element has other child elements then there may be multiple text nodes that were separated due to the child elements and the text nodes only represent a portion of the full text and the text node will *not* have the text of the other child elements (or sibling elements to the text nodes)
    - For example, let's say we have the following HTML:

    #+BEGIN_SRC html
      <div id="example">
	Hello
	<span>World</span>
      </div>	
    #+END_SRC

    - This creates the following DOM tree (starting with the div to just demonstrate the example)

    #+BEGIN_SRC text
      div
      |- text: "\nHello\n"
	 |- span
	    |- text: "World"
      |- text: "\n"
    #+END_SRC

    - Notice how the text is split because there is a child element in-between
    - Notice how there are multiple text nodes
    - Finally notice the contents within each text node, the first text node only contains "\nHello" and nothing else, this is what is meant by text nodes do not include any text from other child elements (or sibling elements from the text node) because new text nodes are created for those child elements such as the element span in the example

    - There are also other properties to access the contents of the element and those properties are ~.innerHTML~ and ~.textContent~
    - ~.innerHTML~ returns HTML markup as a string so for example ~document.getElementById("example").innerHTML~ will return "Hello\n<span>World</span>" notice how the HTML tags are included
    - If you were to modify ~.innerHTML~ then you may include HTML tags and it will be rendered by the browser onto the web page
    - ~.textContent~ only returns the text inside the element with no tags so for example ~document.getElementById("example").textContent~ will return "Hello World" without any HTML tags
    - If you were to replace ~.textContent~ you will replace all the text with your update string and if you were to include HTML tags then it will *not* render the tags and just treat it as plain text
    - ~.innerHTML~ may be dangerous since you can enter HTML and thus include scripts while ~.textContent~ only inserts plain scripts and is safe from HTML injection
    - So ~.innerHTML~ gets the all the content and HTML tags within an element and you can update the HTML because the browser will render HTML tags
    - ~.textContent~ gets all the plain text inside an element and you can update the plain text with a string and the string will be treated as plain text
    - When an element contains a mix of text and other elements, you are more likely to work with the containing element rather than the idividualnodes for each descendant
      
    - There are other ways to update elements and the DOM tree using methods such as:
      - ~document.createElement()~: creates HTML element
      - ~document.createTextNode()~: creates a text node
    - However just by creating a new HTML element node or a text node does not automatically add them to an existing element or the DOM tree
    - To add an HTML element to the DOM tree you use ~elem.appendChild(<newNode>)~ to add it to an element that is already in the DOM tree
    - If you add the new node to another node that is already in the DOM tree then your new node is added to the DOM tree
    - The same goes for text nodes, text nodes are needed to be added to an element, this element can be already in the DOM tree or be added later
    - You can also insert the text node using ~appendChild()~, ~insertBefore()~, or any other valid method
    - You may also remove elements using ~removeChild(<node>)~
    - Creating, inserting and removing nodes in the DOM is called DOM manipulation

    - Finally, you can access or update attribute values such as the attributes "class" and "id"
    - To get the classes and id of an element you simply use the attributes ~<elem>.className~ or ~<elem>.id~ and you can override such attributes
    - However, there are methods to manipulate attributes, for example ~hasAttribute()~ checks if an attribute exists, ~getAttribute()~ gets the value of the attribute, ~setAttribute()~ updates the value of the attribute, and ~removeAttribute()~ removes an attribute
    
    - To work with the content of elements you can: navigate to the text nodes (works best when elements only contains text no other elements) or when can work with the containing element because this allows you to access its text nodes and child elements (works best if the element has text nodes and child elements that are siblings)
    - Once you have navigated from an element to its text node, there is one property that you will use and that is ~nodeValue~ which accesses text from the node
    - When you are working with an element node (rather than its text node) that element can contain markup so you have to choose whether you want to retrieve (get) or update (set) the markup as well as the text
    - For example, ~innerHTML~ gets / sets the text & HTML markup while ~textContent~ and ~innerText~ gets and sets text only
    - When you use these properties to update the content of an element, the new content will overwrite the entire contents of the element both text and markup

**** Section 5.3.2.1: Accessing the Text Node
     - When you select a text node, you can retrieve or amend the content of it using the ~nodeValue~ property
     - In order to use the ~nodeValue~ you must be on a text node, not the element that contains the text
     - To work with text in an element, first the element node is accessed and then its text node
     - The text node has a property called ~nodeValue~ which returns the text in that next node
     - You can also use the ~nodeValue~ property to update the content of a text node

**** Section 5.3.2.2: Accessing Text (Not Text Node)
     - ~textContent~ property allows you to collect or update just the text that is in the containing element and its children
     - Why do I mean by that? Basically, ~textContent~ will retrieve all the text from all text nodes *including* from child elements
     - For example, let's say we have the following HTML:

     #+BEGIN_SRC html
       <p>Hello <span>World</span></p>
     #+END_SRC

     - This will produce a DOM tree as such:

     #+BEGIN_SRC text
       p
       |- text: "Hello "
       |- span
	  |- text: "World"
     #+END_SRC

     - So what ~textContent~ will do, it will try to find all text nodes that are children of the node or text nodes that are descendants of the node
     - In this case we have two text nodes and it will retrieve the text and return it so it will retrieve "Hello " + "World" = "Hello World"
     - So ~textContent~ will retrieve all text from all text nodes that are descendants even if the text node are not direct children of the containing node
     - You can also use this property to update the content of the element but it is replaces the entire content of it (including any markup)
     - *Assumption*: I'm assuming what it does when we update the content, it replaces all children involved (directly like the text nodes or indirectly like the parent of a descendant of a text node) with a single text node that holds the updated value
     - This is why updating the content of ~textContent~ will replace the entire content including any markup thus possibly changing your HTML web page (not just like the text)
     - There is also another property that is similar to ~textContent~ and that is ~innerText~
     - The difference is that ~innerText~ takes into account CSS rules and gets the text of how it actually appears on the screen
     - Thus if the CSS rule says to hide the element (e.g. ~display: none~) then it won't show it, if the CSS element says uppercase but the actual HTML is in lowercase then instead of showing it lowercase like in ~textContent~, it will show it in uppercase in ~innerText~, if there are new line characters then it will show it in ~innerText~
     - ~innerText~ will show the text just as how it appears by respecting the CSS rules
     - However, because it takes into account CSS rules it is slower than ~textContent~
     - You can also update ~innerText~ but will replace all child elements with a single text node with the value given just like ~textContent~

**** Section 5.3.2.3: Adding or Removing HTML Content
     - There are two very different approaches to adding and removing content from a DOM tree: ~innerHTML~ property and DOM manipulation
     - There are security risks associated with using ~innerHTML~ but ~innerHTML~ can be used on any element node
     - ~innerHTML~ can be used to retrieve and replace content
     - To update an element using ~innerHTML~ the new content is provided as a string and it can contain markup for descendant elements
     - So to add new content for ~innerHTML~ you store new content (including markup) as a string in variable, you select the element whose content you want to replace, and you set the element's ~innerHTML~ property to be the new string
     - To remove content from ~innerHTML~ you either provide an empty string or if you want to remove a single descendant and not remove the rest then you provide the entire markup in the new string but now *without* the element you want to remove
     - DOM manipulation easily targets individual nodes in the DOM tree whereas ~innerHTML~ is better suited to updating entire fragments within a node
     - DOM manipulation can be safer than using ~innerHTML~ but it requires more code and can be slower
     - DOM manipulation refers to a set of DOM methods that allow you to create elements and text nodes, and then attach them to the DOM tree or remove them from the DOM tree
     - To add content (via DOM manipulation) you use a DOM method to create a new node with some stype of content, one at a time, and store it in a variable then another DOM method is used to attach the node in the correct position in the DOM tree
     - You can also remove nodes along with its content and child nodes from the DOM tree using a DOM method

***** Section 5.3.2.3.1: Inner HTML
      - Using the ~innerHTML~ property you can access and amend the contents of an element including any child elements
      - When getting HTML from an element, the ~innerHTML~ property will get the content of an element and return it as one long string including markup that the element contains
      - When used to set new content for an element, it will take a string that /can/ contain markup and process that string adding any elements within it to the DOM tree
      - When adding new content using ~innerHTML~, be aware that one missing closing tag would throw out the design of the entire page
      - Even worse, if ~innerHTML~ is used to add content that your users created to a page, they could add malicious content
      - Any new elements will also be available to other scripts in the page
      - Quotation marks can be escaped whenever you need to use them such as in attributes for elements
	
***** Section 5.3.2.3.2: DOM Manipulation
      - DOM manipulation offers another technique to add new content to a page (rather than ~innerHTML~)
      - To add nodes to DOM, there are 3 steps:
	1. Create the element using ~createElement()~, store it in a variable but note that when the element node is created it is not yet part of the DOM tree
	2. Create the text node using ~createTextNode()~, store it in a variable, modify the ~nodeValue~ to add text or use the parameter in the function ~createTextNode()~, and add it to the element using ~appendChild()~
	3. Then you add it to the DOM, just like how you added the text node to the element node, you now have to add the element node to the DOM or add it to another element that is already in the DOM by using ~appendChild()~ so now the newly created element can be a child of the ~document~ object or some other element
      - You can technically add nodes to the other nodes that are still not in the DOM tree, the only time the nodes are added to the DOM tree is when you add the node to an existing element that is already present in the DOM, otherwise it won't be in the DOM tree
      - There are other methods to add newly created elements to other nodes (either living in the DOM tree or not) such as ~insertBefore()~ which adds an element before the selected DOM node
      - Some developers leave empty elements in the HTML so content can be added later via JS but this practice should be avoided unless absolutely necessary instead they should create the element in JS and add it via the DOM methods as needed and not create an empty HTML element
      - DOM manipulation can also be used to remove elements from the DOM tree
        1. We get and select the element we want to remove and store the element in a variable
	2. Find, select, and store the parent of the element you want to remove and the simplest way to get this element is to use the ~parentNode~ property
	3. Using the parent element you call the method ~removeChild()~ and the method takes in one parameter which is the reference to the element you want to remove or the node that will be removed
      - When you remove an element from the DOM it will also remove any child elements
      - Also adding or removing elements from the DOM will affect the ~NodeList~ of siblings or children

***** Section 5.3.2.3.2: Comparing Techniques to Update HTML
      - There are 3 ways to add HTML to a web page
	- ~document.write()~: Simple way to add content to the page and DOM by passing a string with markup as the argument but this feature is no longer recommended and deprecated
	- ~innerHTML~: An element property that lets you get / update the entire content of any element (including markup) as a string
	- DOM Manipulation: DOM manipulation refers to a set of methods and properties to access, create, and update elements and text nodes
      - The ~document.write()~ is quick and easy to add content to a page but only worked when the page initially loads and can have unexpected behavior so it is no longer used and it is deprecated
      - The ~innerHTML~ property is another easy way to add and remove large amount of elements with very little code since it uses a string and it can be much faster than DOM manipulation but it should *not* be used when the content comes from the user (e.g. a username text box) due to security risks, it is harder to isolate elements, and event handlers may no longer work
      - DOM manipulation allows you to isolate and modify single elements, it does not affect event handlers, and elements can be added incrementally by the script but the downside of this is that DOM manipulation is slower than ~innerHTML~ and it requires more code to change and alter elements compared to ~innerHTML~

** Section 5.4: Security Risks
   - If you add HTML to a page using ~innerHTML~ or several jQuery methods you need to be aware of Cross-Site Scripting Attacks or XSS
   - These attacks can be detrimental with potential exposed data or unauthorized access
   - XSS involves an attacker placing malicious code into a site, for example users may be able to write comments, create profiles, post an article, modify an article, upload a file or video and in addition data / code may  come from third-party sites such as Facebook, Twitter, etc.
   - Data you do not have complete control over is known as untrusted data and it must be handled with care
   - XSS attacks can give the attacker information on the DOM, website's cookies, session tokens (info that identifies you as the user as not some other user) and this can be used complete actions (e.g. purchases, publish, delete) with that account, post defamatory content, and spread more malicious code further / faster
   - Any HTML from untrusted sources open your site to XSS attacks but the threat is only from certain situations and characters

*** Section 5.4.1: Defending Against Cross-Site Scripting
    - Validate input going to the server
    - Only let visitors input the kind of characters they need to when supplying information and this is known as validation (do not allow untrusted users to submit HTML markup or JavaScript, better do not let anyone submit HTML markup or JS)
    - Validate input again (double check) on the server before displaying user content / storing it in a database because if you do some type of validation in JS, users can turn off JS in the browser and bypass client-side validation so it is better to also do server-side validation
    - The database itself may safely contain markup and script from trusted sources because DBs do not run HTML or JS, DBs simply store the data they do not process code
    - After the DB returns data all potentially dangerous characters should be escaped
    - Then you make sure that you are only inserting content generated by the users into certain parts of the template files only where it is necessary
    - Finally, do not create DOM fragments containing HTML from untrusted sources as it should only be added as text once it has been escaped
    - Thus, the developer should be the only one using ~innerHTML~ (if the developer wrote the markup) but content from any untrusted sources (like users) should be escaped and added as text (not markup) using properties like ~textContent~

*** Section 5.4.2: Validation & Templates
    - Make sure that your users can only input characters they need to use and limit where this content will be shown on the page
    - Most basic defense to these attacks is to prevent users from entering specific characters into form fields especially the characters that are not needed
    - For example, in email text boxes characters such as angled brackets, ampersands, or parentheses are not needed and should be prevented from being entered
    - This type of validation can be done in both the browser (client-side) and in the server (server-side)
    - Even websites that do allow you to enter markup limit the type of markup you can enter, for example, it may not let you enter ~<script>~ tags, elements with an event handling attribute, or it may not even let you enter a lot of HTML, it may even want to correct any markup that looks malicious
    - Malicious users will not /just/ use ~<scirpt>~ tags to try and create an XSS attack as malicious code can also live in an event handler attribute (without needing to use ~<script>~ tags)
    - XSS attacks can also be triggered by code in CSS or URLs
    - Since browsers process HTML, CSS, and JS differently then different characters can cause problems which is why you should only add content from untrusted sources as text (not markup) and place that text in elements that are visible in the viewport
    - Never place any user's content in the following places without detailed experience of the issues involved:
      - Script tags
      - HTML comments
      - Tag names
      - Attributes
      - CSS values

*** Section 5.4.3: Escaping & Controlling Markup
    - Any content generated by users that contain characters that are used in code should be escaped on the server (you must control any markup added to the page)
    - All data from untrusted sources should be escaped on the server before it is shown on the page and most server-side languages offer helper functions to strip-out or escape malicious code
    - For example instead of using the character "&" it is best to escape the character and use "&amp" for HTML
    - For JS, never include data from untrusted sources in JS which means escaping all ASCII characters with a value less than 256 that are not alphanumeric characters because that can be a security risk
    - For URLS use the JS ~encodeURIComponent()~ method to encode the user input which encodes the following characters: ~,~, ~/~, ~?~, ~:~, and more
    - When you add untrusted content to an HTML page, once it has been escaped on the server, it should still be added to the page as text and JS and jQuery both offer tools for doing this:
      - For JS use ~textContent~ and ~innerText~ instead of ~innerHTML~
      - For jQuery use ~.text()~ instead of ~.html()~
    - You can still use ~innerHTML~ or ~.html()~ but you have to make sure that you control *all* of the markup being generated (not outside users) and the actual user's content does not use the HTML methods instead the content is escaped and treated as text and use the text methods

** Section 5.5: Attribute Nodes
   - Once you have an element node, you can use other properties and methods on that element node to access and change its attributes
   - There are two steps to accessing and updating attributes:
     1. Select the element node that carries the attribute
     2. Use the dot operator to use one of the methods or properties to work with that element's attributes
   - Methods to access and change attributes of an element:
     
   | Method / Property   | Description                                      |
   |---------------------+--------------------------------------------------|
   | ~getAttribute()~    | Gets the value of an attribute                   |
   | ~hasAttribute()~    | Checks if element node has a specified attribute |
   | ~setAttribute()~    | Sets the value of an attribute                   |
   | ~removeAttribute()~ | Removes an attribute from an element node        |
   | ~className~         | Gets or sets the value of the ~class~ attribute  |
   | ~id~                | Gets or sets the value of the ~id~ attribute     |

   - Properties of an element (object) coresspond to the attributes that type of element can carry
   - For example, ~href~, ~checked~, ~title~, etc. may be properties of the element's object but may or may not have valid values depending on the type of element itself
   - Other properties include ~className~ and ~id~ which an element may or may not have
   - The ~className~ property allows you to change the value of the ~class~ attribute and if the attribute does not exist it will be created and given the specified value
   - However instead of using ~className~ we can use ~setAttribute()~ to update the value of /any/ attribute, it takes two parameters the attribute name and value for the attribute
   - Generally when there is a property for the attribute like ~className~ or ~id~ it is generally considered better to update the properties rather than use a method because the method will simply use the properties to update the value
   - Changing the ~className~ can trigger new CSS rules and change the appearance of the elements
   - By changing the value of class either through ~className~ or the method you will be overriding the entire value of the ~class~ attribute, they do not add a new value to the existing value of the ~class~ attribute
   - Instead you can add or remove idividual class names by using the property ~.classList~ and the method ~.classList.add()~ or ~.classList.remove()~
   - In jQuery you can also use the method ~.addClass()~
   - Before you work with an attribute, it is good practice to check whether it exists because this will save resources if the attribute cannot be found
   - The ~hasAttribute()~ method of any element node lets you check if an attribute exists and the attribute name is given as an argument in parentheses
   - To remove an attribute from an element, first select the element, then call ~removeAttribute()~ and it only has one parameter which is the name of the attribute to remove
   - Trying to remove an attribute that does not exist will not cause an error but it is good practice to check for its existence before attempting to remove it

** Section 5.6: Chapter Exercise
   - We are going to create a todo-list purely from JS
   - We will not have HTML elements instead we are going to create the elements in JS
   - This will help us understand the DOM tree and understand how to change the DOM tree
   - Our todo-list will have the following features:
     1. Add an item to the list
     2. Remove an item from the list
     3. Mark an item to be finished
     4. Keep track of recently deleted items
   - The entire body will be done using JS via DOM manipulation
   - [[file:./005.006.Chapter_Exercise/index.html][Here is the Todo Web App]]

** Section 5.7: Summary
   - The browser represents the page using a DOM tree
   - DOM trees have four main types of nodes: document nodes, element nodes, attribute nodes, and text nodes (there are more nodes but these are the main ones)
   - You can select element nodes by their id or class attributes, by tag name, or using CSS selector syntax
   - Whenever a DOM query can return more than one node it will always return a ~NodeList~
   - From an element node you can access and update its content using properties such as ~textContent~ and ~innerHTML~ or using DOM manipulation techniques
   - An element node can contain multiple text nodes and child elements that are siblings to each other
   - In older browsers, implementation of the DOM is inconsistent and is a popular reason for using jQuery; however, with modern browsers and other frameworks jQuery has decreased in popularity
   - Browsers offer tools for viewing the DOM tree
    
* Keywords
| Term                    | Definition                                                                                                                                                                                                                                                                                                                                                |
|-------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| DOM                     | The Document Object Model (DOM) is the data representation of the objects that comprise the structure and content of a document on the web, basically, DOM is a programming interface for web documents that represent the page so that programs can change the document structure, style, and content                                                    |
| DOM Tree                | The DOM tree is a hierarchical representation of an HTML or XML document structured as a tree where each element, attribute, and text content is a node and the tree-like structure allows programming languages like JS to interact with and manipulate the web page's content, structure, and styles                                                    |
| Document Node           | The document node is the topmost root node in the DOM tree that represents the entire HTML or XML document as it is the entry point to access all elements in a web page, the document node does not represent any visible content but acts as a container for the rest of the nodes in the DOM                                                           |
| Element Node            | The element node in the DOM represents an HTML or XML element like ~<div>~, ~<p>~, and so on as it directly corresponds to the tags in the HTML or XML document, these elements may have attributes, child nodes, and text content                                                                                                                        |
| Attribute Node          | The attribute node in the DOM represents an attribute of an HTML or XML element such as ~class~, ~id~, ~href~, etc. the element node can have zero or more attribute nodes and these attribute nodes are *not* considered to be child nodes of the element node                                                                                           |
| Text Node               | Text nodes in the DOM represent the actual text content inside an element or attribute (not the element or attribute itself), these text nodes are always leaf node and only contain the text value under the property ~nodeValue~                                                                                                                        |
| ~.innerHTML~ Property   | Retrieves and sets all the HTML content inside the element, the value is a string with HTML markup so you can retrieve this string or you can set a new string and it will process HTML markup and replace all child elements with the new HTML given                                                                                                     |
| ~.innerText~ Property   | ~innerText~ retrieves text from all child elements and stores it into a string just like how it is displayed depending on the CSS rules, if the CSS rule says the text is uppercase then the string will be in uppercase; it does not have markup and you can set the value of ~innerText~ but it will replace all child elements with a single text node |
| ~.textContent~ Property | ~textContent~ is similar to ~innerText~ as it gets all the text from the child elements but it only gets the text from the HTML, if any CSS rule is applicable it will be ignored in the string, you can also replace the string but it will replace all child elements with a single text node with the value given                                      |

* Questions
  - *Q*: How does DOM treat whitespaces?
         - DOM creates text nodes for whitespace characters
	 - So if you have the following:
	 #+BEGIN_SRC html
	   <div>
	     <p>Hello World</p>
	   </div>
	 #+END_SRC
	 - It will create a element node for ~div~ then it will create 3 child nodes, one text node for the first newline character, the second node for the element ~p~, and the third node for the next newline character
	 - So whitespace characters are preserved in DOM and treated as part of the content in the text node
	 - The actual content in text nodes is preserved exactly as it appears in the HTML
	   
  - *Q*: How does DOM treat attributes?
         - DOM creates nodes for the attributes but these attributes are not children of the element node
	 - Instead attribute nodes are stored as part of the element node
	 - Attributes are treated as name-value pairs with the name of the attribute and its value
	 - Attribute nodes are case-insensitive and again they are not children of the element but part of the element as properties
	   
  - *Q*: Which nodes are leaf nodes and why isn't attribute nodes considered leaf nodes?
         - The nodes that can be leaf nodes are text nodes, comment nodes, and empty elements (no children)
         - Attribute nodes are not considered leaf nodes because attributes are not part of the child-node hierarchy because they are associated with the element node itself as a property / metadata
	 - Since attribute nodes are not children of the element, they do not appear in the node's child list and thus not part of the document's tree structure because they are a part of the element itself
	 - So attributes cannot be leaf nodes because they are not even considered as part of the tree instead they are considered as properties of the element itself
	   
  - *Q*: Is there a function or property that gets the text node directly?
         - No there is not a direct way to get the text node
	 - Instead you would have to use other methods / properties
	 - You could use the child nodes of the element, iterate through the list, and find the node whose's type is a text node
	 - You could use the property ~.textContent~ to change the text content inside the element

  - *Q*: What is the difference between ~.innerHTML~, ~.innerText~, and ~.textContent~?
         - The ~.innerHTML~ property allows you to get or set the HTML content inside an element with a string containing HTML markup
	 - This string is processed by HTML to add elements to the DOM
	 - ~.innerText~ returns or sets the visible text content from all its children as a string as it appears after the CSS rules have been applied
	 - So if some text is hidden by CSS then the text will not show up, if some text is uppercased by CSS then the string will return text uppercased
	 - ~.innerText~ does not contain HTML markup, it only returns plain text
	 - ~.textContent~ is similar to ~.innerText~ but it does not consider CSS styles so it will return the text of all children elements as plain text without any CSS changes just like how it appears in HTML
	 - ~.textContent~ does not contain HTML markup
	 - So ~.innerHTML~ gets and sets HTML markup, ~.innerText~ gets and sets plain text with CSS stylings, and ~.textContent~ gets and sets the raw text content without any CSS stylings
	   
  - *Q*: What is the difference between live ~NodeList~ and static ~NodeList~?
         - Both live ~NodeList~ and static ~NodeList~ are ~NodeList~ which is a collection of nodes but the only difference between the two is how they update in response to changes in the DOM tree
	 - For live ~NodeList~ when the DOM is changed and modified, the ~NodeList~ will have those changes in real-time without having to do anything
	 - The live ~NodeList~ will reflect the changes in DOM dynamically and is always kept in sync with the current state of the document
	 - Methods that return live ~NodeList~ are: ~getElementsByTagName()~ and ~getElementsByClassName()~
	 - Static ~NodeList~ is a snapshot of the nodes that match the query when the ~NodeList~ was created
	 - Once a static ~NodeList~ is created, it does not update if the DOM changes, the content of a NodeList is frozen at the time it was created
	 - The method that returns static ~NodeList~ is ~querySelectorAll()~ 
	   
  - *Q*: Do all scripts use the same DOM tree, so if one script affects the DOM tree does the other script see the changes?
         - There is a single DOM object for one page, so all scripts running in the web page will have the same shared DOM
	 - Thus if one script changes the DOM, those changes will be reflected in the DOM tree and the other script running on the same page will see the updated DOM
	 - The DOM is a global representation of the HTML document in the browser so all scripts on the page interact with the same DOM
	 - Thus any changes to DOM is visible to all scripts
* Summary
  - The Document Object Model (DOM) specifies how browsers should create a model of an HTML page and how JS can access and update the contents of a web page while it is in the browser window
  - DOM is not part of HTML or JS instead it is implemented by all major browsers that make the model of the HTML page and based on the model allows JS to access and change the HTML page
  - When a page is loaded the browser creates a model of the page in memory and DOM specifies the way in which the browser should structure this model using a DOM tree
  - DOM defines methods and properties to access and update each object in the DOM tree which is why the DOM is sometimes referred to as an application programming interface (API)
  - The DOM tree is stored in the browser's memory and it consists of four main types of nodes: document nodes, element nodes, attribute nodes, and text nodes
  - The document node is the root node (~document~ node) and it represents the entire page
  - Every tree node in the DOM tree is an object even the leaf nodes
  - Text nodes are created for whitespace characters
  - Attribute nodes are not part of the hierarchical tree structure instead the attribute nodes are part (properties) of the element nodes
  - To retrieve nodes (objects) from the DOM tree there are many ways, you can use methods (DOM queries) or properties to traverse the DOM tree
  - To retrieve single nodes using the DOM queries you use the following methods: ~getElementByID()~ and ~querySelector()~
  - To retrieve multiple nodes using DOM queries you use the following methods: ~getElementsByClassName()~, ~getElementsByTagName()~, and ~querySelectorAll()~
  - The methods that retrieve multiple nodes will return a ~NodeList~
  - The ~NodeList~ may be live or static depending on the method used
  - Methods that start like ~getElementsBy~ will return live ~NodeList~ that means any changes to the DOM will automatically be reflected in the ~NodeList~ if applicable
  - The method ~querySelectorAll()~ returns static ~NodeList~ and static lists do not change if the DOM changes instead they capture or store the query results of the DOM query at the time of the query and does not change after if the DOM changes
  - You can also traverse through the nodes by using the properties ~parentNode~, ~previousSibling~, ~nextSibling~, ~firstChild~, and ~lastChild~
  - To access the contents of a node you can use the properties and methods of the node
  - To access a node's text, you can access it's child text node, however there is no property or function that directly gives you the text node instead you will need to use other methods / properties to get the text node
  - Once you have access to the text node you can use the property ~nodeValue~ to get the text from the text node
  - Some elements may have multiple text nodes so you will have to go through each one to get the full text
  - Instead you can use the property ~.textContent~ of the element to retireve or set the text from all children of the element
  - ~textContent~ will retrieve all text as a string with plain text
  - You could also use ~.innerText~, it is similar to ~textContent~ in the sense that you can replace or retrieve the value but it will reflect any CSS stylings such as hidden text will be hidden, uppercase text will be uppercased, etc.
  - Or you could use ~.innerHTML~ but the string stored in ~.innerHTML~ is the actual HTML markup with the tags so if you were to replace the value with a string, the string may contain HTML markup and DOM will reflect the changes added / removed from ~.innerHTML~ because it understands to process the string as HTML markup
  - However ~.innerHTML~ can lead to security risks (due to being able to add malicious HTML with script tags) so it is best to avoid ~.innerHTML~ if possible and if we need to use it then we should be the only person who uses ~.innerHTML~
  - Some websites receive user input so always validate input in the client-side and server-side, never add user input into script tags, HTML comments, tag names, attributes, CSS values, and always escape your strings on the server before the browser processes it
  - There are functions to create and remove nodes from the DOM tree using the ~document~ object
  - You can use the functions ~createElement()~ and ~createTextNode()~ to create nodes and then use the methods ~appendChild()~ or ~insertBefore()~ to add nodes to existing nodes
  - You can remove nodes by the functions ~removeChild()~
  - Also just because you created an element or node, does *not* mean you have added the node to the DOM tree
  - To add newly created objects (nodes) to the DOM tree you need to append it as a child to an already existing node in the DOM tree
  - If you append the newly created node to another node that is not in the DOM tree then both nodes do not exist in the DOM tree and it will not show up in the web page
  - You have to add the newly created node to a node that is already present in the DOM tree so it can be successfully added to the DOM tree and shown in the page
  - To add new elements in HTML you can use ~.innerHTML~, DOM manipulation with the methods shown above, or with ~document.write()~
  - Although DOM manipulation may be slower and requires more code it may be more secure than ~innerHTML~ and ~document.write()~ has since been deprecated and should no longer be used
  - Finally, attribute nodes are not child nodes of the element but part of the element itself
  - Attribute nodes can be retrieved, checked for, set, and removed using the following functions: ~getAttribute()~, ~hasAttribute()~, ~setAttribute()~, and ~removeAttribute()~
  - However, depending on the object you may have access to the attribute directly, for example, for links instead of saying ~setAttribute("href", "www.example.com")~ you have be able to access it using ~.href~
  - It is better to use these properties directly if possible because it is faster and because behind the scenes the methods shown above regarding attributes use these same properties to set attributes, check attributes, get attributes, and remove attributes
    
* Resources
  - https://javascript.info/dom-nodes
