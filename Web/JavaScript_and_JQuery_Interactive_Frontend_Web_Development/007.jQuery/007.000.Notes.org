#+title: Chapter 7: jQuery
#+author: Alfredo Mejia
#+options: num:nil html-postamble:nil
#+html_head: <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css" /> <style>body {margin: 5%} h1,h2,h3,h4,h5,h6 {margin-top: 3%} .content ul:not(:first-child) {margin-top: 0.25em}}</style>

* Navigation
| Nav   | Title                                                       | Links                                   |
|-------+-------------------------------------------------------------+-----------------------------------------|
| Index | Notes Home                                                  | \vert [[file:../../../index.html][html]] \vert [[file:../../../index.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main][github]] \vert |
| Home  | JavaScript & JQuery - Interactive Front-end Web Development | \vert [[file:../000.Home.html][html]] \vert [[file:../000.Home.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development][github]] \vert |
| Prev  | Chapter 6: Events                                           | \vert [[file:../006.Events/006.000.Notes.html][html]] \vert [[file:../006.Events/006.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/006.Events][github]] \vert |
| Next  | Chapter 8: AJAX & JSON                                      | \vert [[file:../008.Ajax_and_JSON/008.000.Notes.html][html]] \vert [[file:../008.Ajax_and_JSON/008.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/008.Ajax_and_JSON][github]] \vert |

* Notes

** Section 7.1: Introduction
   - jQuery offers a simple way to achieve a variety of common JavaScript tasks quickly and consistently across all major browsers and without any fallback code needed
   - It is simpler to access elements using jQuery's CSS-style selectors than it is using DOM queries (the selectors are more flexible and powerful)
   - jQuery's methods let you update the DOM tree, animate elements into and out of view, and loop through a set of elements, all in one line of code
   - jQuery includes methods that allow you to attach event listeners to selected elements without having to write any fallback code to support older browsers
     
** Section 7.2: What is jQuery?
   - jQuery is a JS file that you include in your web pages
   - jQuery lets you find elements using CSS-style selectors and then do something with the elements using jQuery methods

*** Section 7.2.1: Finding Elements using CSS-Style Selectors
    - A function called ~jQuery()~ lets you find one or more elements in the page
    - This function creates an object called ~jQuery~ which holds references to those elements
    - ~$()~ is often as a shorthand to save typing ~jQuery()~
    - Example, let's say we have a link called "existing" and we run ~jQuery("a.existing")~ then it will return an object with the references to those elements
    - The ~jQuery()~ function has one parameter: a CSS-style selector
    - ~jQuery~ selectors perform similar task to traditional DOM queries but syntax is much simpler because all you need to do is ~$()~
    - You can store the ~jQuery~ object in a variable, just like DOM nodes, and the ~jQuery~ object has methods and properties to manipulate the DOM nodes that you have selected just like DOM properties and methods

*** Section 7.2.2: Do SOmething with Elements using jQuery Methods
    - ~jQuery~ object has many methods that you can use to work with the elements you select, these methods represent tasks that you commonly need to perform with elements
    - After using ~jQuery()~ the object and the elements it contains is referred to as a *matched set* or a *jQuery selection*
    - You can then use the methods of the ~jQuery~ object to update the elements it contains
    - For example, the method ~$().addClass()~ adds a new value to the class attribute for all the elements selected (the matched set)
    - The differences from DOM is that jQuery is cross-browser and does not need to have fallback code
    - Thus selecting elements is simpler (also due to CSS-style syntax and the shorthand of the method ~jQuery()~), add event handlers is also simple because it is cross-browser, methods affect all elements in the matched set without a need of the loop, additional methods are provided for animation, and once you have a set of elements you can apply multiple methods to it

*** Section 7.2.3: A jQuery Example
    - To use jQuery you need to include the jQuery script into your web page
    - Once jQuery is added you can then import your own JS file that would be using jQuery
    - Many people using jQuery use the minified file of jQuery so it ends with the extension ~.min.js~
    - This file went through a process called minification which involves unnecessary spaces, carriage returns, comments being stripped from the code, and optimizations to make the file smaller and faster to load (although minified files are hard to read)
    - You do not need to understand the jQuery code, all you need to know is how to select elements and use its methods and properties
    - Example:

    #+BEGIN_SRC javascript
      $(":header").addClass("headline");
      $("li:lt(3)").hide().fadeIn(1500);
      $("li").on("click", function(){ $(this).remove(); });
    #+END_SRC

    - The first line selects all of the ~<h1> - <h6>~ headings and adds a value of "headline" to their class attributes
    - The second line selects the first 3 list items and hides the elements, the reason why it hides them because if they are shown then how can they fade in, so after hiding them the elements are faded into view to give an animation of fading elements from unseen to seen
    - Notice the selector ~:lt(3)~, this is a jQuery specific selector, it stands for "less than" and it uses a zero-based indexing, so it filters the selection to items with an index less than 3, so the first list item is index 0 and the next is index 2 and so on, so ~lt(3)~ wants to get only the list items that have an index "less than" 3
    - The last line of the code set an event listener on each ~<li>~ element and when the user clicks on one then it triggers an anonymous function
    - Inside this anonymous we can have ~element.target~ to get the target element or ~this~ (only if the event handler was added directly to the target element) so we use ~this~ with ~$()~ and whenever you give a DOM element to the function ~jQuery()~ or ~$()~ then you are basically wrapping the DOM element in a jQuery object giving you access to all of jQuery's powerful methods
    - So the last line of code, we add an event handler, inside the anonymous function we get the target element using ~this~, we wrap it in a jQuery object, and then we finally call ~remove()~ on the object because this jQuery method removes the selected elements from the DOM completely along with all their child elements and associated data and event handlers
    - Thus the last line of code is basically adding an event listener so when a user clicks on a list item it triggers a function that removes the element from the page

** Section 7.3: Why Use jQuery?
   - jQuery does not do anything you cannot achieve with pure JS, it is a JS file at the end but it can make coding simpler
   - This is outdated but before selecting the elements you wanted was hard because older browsers did not support the lastest methods for selecting elements and IE did not treat whitespace as text nodes like the other browsers
   - This makes it hard to select the right elements across all major browsers so jQuery instead uses CSS selectors to select elements because CSS selectors are fast at selecting elements, are more accurate about which elements to select, require less code (compared to older DOM methods), and is already used by most front-end developers
   - In addition, jQuery adds extra selectors or extends the set of CSS selectors to offer greater functionality (these extensions are part of jQuery and do not work in CSS) such as ~:contains("text")~ which matches elements that contain the specified text
   - DOM has their own CSS selector functions called ~querySelector()~ and ~querySelectorAll()~ but when they were introduced these methods were not supported by older browsers
   - jQuery has methods that offer web developers simpler ways to perform common tasks such as loop through elements, add or remove elements from the DOM tree, handle events, fade elements into / out of view, and handle ajax requests, thus writing less code to achieve those tasks
   - jQuery also offers chaining of methods, so once you have selected some elements, this allows you to apply multiple methods to the same selection
   - jQuery is cross-browser compatible so instead of writing cross-browser fallback code, jQuery uses feature detection to find the best way to achieve a task by using conditional statements such as if the browser supports this then do this, if not check if it supports this, if not resort to last option (similar to checking if the browser supported methods in the previous chapter)
   - During the time, jQuery was building a lot of code to support IE6, 7, and 8 (older browsers) and starting with jQuery 2.0 support for older browsers would be dropped but a lot of people still used older browsers at the time so the jQuery team decided to maintain two parallel versions of jQuery: jQuery 1.9+ and jQuery 2.0+
   - This book is outdated and we are now in jQuery 3.0+ with no plans to ever release jQuery 4.0

** Section 7.4: Finding Elements
   - With jQuery you select elements using CSS-style selectors but jQuery also offers some extra selectors that are not part of CSS

   - *Basic Selectors:*
   | Selector               | CSS or jQuery                | Description                                                                                                                 |
   |------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------|
   | ~*~                    | CSS                          | Selects all elements                                                                                                        |
   | ~element~              | CSS                          | All elements with that element name                                                                                         |
   | ~#id~                  | CSS                          | Elements whose ~id~ attribute has thevalue specified                                                                        |
   | ~.class~               | CSS                          | Elements whose ~class~ attribute has the value specified                                                                    |
   | ~selector1, selector2~ | CSS                          | Elements that match more than one selector (see also the ~.add()~ method which is more efficient when combining selections) |

   - *Hierarchy Selector*
   | Selector              | CSS or jQuery | Description                                                                                                                                           |
   |-----------------------+---------------+-------------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~ancestor descendant~ | CSS           | An element that is a descendant of another element (e.g. ~li a~)                                                                                      |
   | ~parent > child~      | CSS           | An element that is a direct child of another element (you can use ~*~ in the place of the child to select all child elements of the specified parent) |
   | ~previous + next~     | CSS           | Adjacent sibling selector only selectors elements that are immediately followed by the previous element                                               |
   | ~previous ~ siblings~ | CSS           | Sibling selector will select any elements that are a sibling of the previous element                                                                  |

   - *Basic Filters*
   | Selector         | CSS or jQuery | Description                                                              |
   |------------------+---------------+--------------------------------------------------------------------------|
   | ~:not(selector)~ | CSS           | All elements except the one in the selector (e.g. ~div:not('#summary')~) |
   | ~:first~         | jQuery        | The first element from the selection                                     |
   | ~:last~          | jQuery        | The last element from the selection                                      |
   | ~:even~          | jQuery        | Elements with an even index number in the selection                      |
   | ~:odd~           | jQuery        | Elements with an odd index number in the selection                       |
   | ~:eq(index)~     | jQuery        | Elements with an index number equal to the one in the parameter          |
   | ~:gt(index)~     | jQuery        | Elements with an index number greater than the parameter                 |
   | ~:lt(index)~     | jQuery        | Elements with an index number less than the parameter                    |
   | ~:header~        | jQuery        | All ~<h1> - <h6>~ elements                                               |
   | ~:animated~      | jQuery        | Elements that are currently being animated                               |
   | ~:focus~         | CSS           | The element that currently has focus                                     |

   - *Content Filters*
   | Selector            | CSS or jQuery | Description                                                                                                                                      |
   |---------------------+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~:contains('text')~ | jQuery        | Elements that contain the specified text as a parameter                                                                                          |
   | ~:empty~            | jQuery        | All elements that have no children                                                                                                               |
   | ~:parent~           | jQuery        | All elements that have a child node (can be text or element)                                                                                     |
   | ~:has(selector)~    | jQuery        | Elements that contain at least one element that matches the selector (e.g. ~div:has(p)~ matches all ~div~ elements that contain a ~<p>~ element) |

   - *Visibility Filters*
   | Selector   | CSS or jQuery | Description                                                                                                                                                                                                                          |
   |------------+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~:hidden~  | jQuery        | Selects all elements that are hidden                                                                                                                                                                                                 |
   | ~:visible~ | jQuery        | All elements that consume space in the layout of the page, not selected if ~:display:none; height / width: 0;~ or ancestor is hidden and selected if ~visibility: hidden; opacity: 0~ because they would take up space in the layout |

   - *Child Filters*
   | Selector           | CSS or jQuery | Description                                                                          |
   |--------------------+---------------+--------------------------------------------------------------------------------------|
   | ~:nth-child(expr)~ | CSS           | Selects the nth child but it uses a 1-based index                                    |
   | ~:first-child~     | CSS           | Selects the first child from the current selection                                   |
   | ~:last-child~      | CSS           | Selects the last child from the current selection                                    |
   | ~:only-child~      | CSS           | Selects the only child of the element only when there is only a child in the element |

   - *Attribute Filters*
   | Selector                     | CSS or jQuery | Description                                                             |
   |------------------------------+---------------+-------------------------------------------------------------------------|
   | ~[attribute]~                | CSS           | Element that carry the specified attribute (with any value)             |
   | ~[attribute='value']~        | CSS           | Elements that carry the specified attribute with the specified value    |
   | ~[attribute!='value']~       | jQuery        | Elements that carry the specified attribute but not the specified value |
   | ~[attribute^='value']~       | CSS           | The value of the attribute begins with this value                       |
   | ~[attribute$='value']~       | CSS           | The value of the attribute ends with this value                         |
   | ~[attribute*='value']~       | CSS           | The value should appear somewhere in the attribute value                |
   | ~[attribute \vert ='value']~ | CSS           | Equal to given string or starting with string and followed by a hyphen  |
   | ~[attribute~='value']~       | CSS           | The value should be one of the values in a space separated list         |
   | ~[attribute][attribute2]~    | CSS           | Elements that match all of the selectors                                |

   - *Form Selectors*
   | Selector    | CSS or jQuery | Description                                                            |
   |-------------+---------------+------------------------------------------------------------------------|
   | ~:input~    | jQuery        | All input elements                                                     |
   | ~:text~     | jQuery        | All text inputs                                                        |
   | ~:password~ | jQuery        | All password inputs                                                    |
   | ~:radio~    | jQuery        | All radio buttons                                                      |
   | ~:checkbox~ | jQuery        | All checkboxes                                                         |
   | ~:submit~   | jQuery        | All submit buttons                                                     |
   | ~:image~    | jQuery        | All ~<img>~ elements                                                   |
   | ~:reset~    | jQuery        | All reset buttons                                                      |
   | ~:button~   | jQuery        | All ~<button>~ elements                                                |
   | ~:file~     | jQuery        | All file inputs                                                        |
   | ~:selected~ | jQuery        | All selected items from drop-down lists                                |
   | ~:enabled~  | CSS           | All enabled form elements (which is the default for all form elements) |
   | ~:disabled~ | CSS           | All disabled form elements (using the HTML ~disabled~ attribute)       |
   | ~:checked~  | CSS           | All checked radio buttons or checkboxes                                |

   - When you select one or more elements, a jQuery object is returned and it is known as a matched set of a jQuery selection
   - If a selector returns one element, the jQuery object contains a reference to just one element node
   - If a selector returns several elements, the jQuery object contains references to each element
   - Each element is given an index number and the index number starts at zero
     
** Section 7.5: jQuery Methods
   - Once you have made a selection of elements then you can now call methods to do some task on the selected elements
   - You often see jQuery method *names* (not the actual code) written starting with a period (~.~) before the name to highlight that those methods are part of the jQuery object and not JS methods or some other object's methods
   - When you make a selection the jQuery object has a property called ~length~ which will return the number of elements in the object
   - If the jQuery selection did not find any matching elements, you will not get an error by calling any of these methods because they simply won't do or return anything
   - There are also methods that are specifically designed to work with Ajax (which lets you refresh part of the page rather than an entire page)
   - So once we have selected the elements we want (and they are in a jQuery object), the jQuery methods perform tasks on those elements
   - These methods:
     - Get or change content of elements, attributes, and text nodes (content filters)
     - Find and select elements to work with & traverse in the DOM
     - Get or update the dimensions or position of a box (dimension / position)
     - Add effects and animation to parts of the page (effects & animation)
     - Create event listeners for each element in the selection (events)
   - To find all the methods available in jQuery for the latest version, visit: https://api.jquery.com
   - Some jQuery methods both retrieve info from, and update the contents of, elements, but they do not always apply to all elements
   - If a jQuery selection holds more than one element and a method is used to get info from the selected elements, it will retrieve info from only the first element in the matched set
   - For example, let's say we have a list and we select the listed items ~$('li')~ and it returns multiple list items, so when we use the ~.html()~ method to get info from each element, it will return the content of the first element in the matched set
   - To get a different element you can use the methods to traverse or filter the selection or we can write a more specific selector
   - To get the content of all of the elements, one way to do so is by the ~.each()~ method
   - If a jQuery selections holds more than one element and a method is used to update information on the page then it will update all of the elements in the matched set not just the first one
   - When you use the ~.html()~ method to update the elements, it will replace the contents of each element in the matched set
   - To update just one element you can use methods to traverse or filter the selection or write a more specific selector
   - So when a method is used on a selection to get information it will only retrieve info only from the first element but if a method is used on a selection to update info then it will update the info for all elements

** Section 7.6: jQuery Objects
   - When you create a selection with jQuery, it stores a reference to the corresponding nodes in the DOM tree, it does not create copies of them
   - jQuery object is an array-like object because it stores a list of the elements in the same order that they appear in the HTML document (thus preserving the order unlike other objects where the order of the properties is not usually preserved)
   - As you have seen, when HTML pages load, the browser creates a model of the page in memory
   - When you create a jQuery selection, the jQuery object holds references to the already existing elements in the DOM so it does not create a copy of them (it uses the references to the already existing elements in the DOM)
   - When programmers say that a variable or object is storing a reference to something, what it is doing is storing the /location/, a piece of info, in the browser's memory
   - To create a jQuery object it takes time, processing resources, and memory because the interpreter must: find the matching nodes in the DOM tree, create the jQuery object, and store references to the nodes in the jQuery object
   - So if the code needs to use the same selection more than once it is better to use the same jQUery object again rather than repeat the above process
   - To do this, you store a reference to the jQuery object in a variable, thus in a sense you are caching a jQuery object by having a variable store the reference to the jQuery object
   - Note that when a variable contains a jQuery object, it is often given a name beginning with the ~$~ symbol to help differentiate it from other variables in your script
   - Caching jQuery selections is similar to the idea of storing a reference to a DOM node once you have made a DOM query

** Section 7.7: Looping & Chaining
   - In plain JS, if you wanted to do the same thing to several elements, you would need to write code to loop through all of the elements you selected
   - With jQuery when a selector returns multiple elements, you can update all of them using the one method and there is no need to use a loop
   - For example ~$('li.em').addClass('seasonal');~ this method is going to add to the class attribute for all the elements that are found using the selector (doesn't matter if there are one or many)
   - The ability to update all of the elements in the jQuery selection is known as *implicit iteration*
   - When you want to get information from a series of elements you use ~.each()~ method rather than writing a loop (more on it later)
   - If you want to use more than one jQuery method on the same selection of elements, you can list several methods at a time using dot notation to separate each one (for example ~$('li').hide().deplay(500).fadeIn(1400);~)
   - Thus the methods act on the same selection of elements and this process of placing several methods in the same selector is referred to as *chaining*
   - Most methods used to update the jQuery selection can be chained however the methods that retrieve info from the DOM (or about the browser) cannot be chained
   - If one of the method in the chain does not work then the rest will not run either

** Section 7.8: Checking a Page is Ready to Work With
   - jQuery's ~.ready()~ method checks that the page is ready for your code to work with
   - For example, ~$(document).ready(function() {});~ this creates a jQuery object represent the page and when the page is ready, the function inside the parentheses of the ~.ready()~ method is run
   - As with plain JS, if the browser has yet constructed the DOM tree then jQuery will not be able to select elements from it so you either use the ~.ready()~ function or you place the script at the end of the page just before the closing ~</body>~ tag (because that point the elements will have been loaded into the DOM tree)
   - A shortcut for the ready event method on the document object is the following: ~$(function() {});~
   - The shorthand above is more commonly used than ~$(document).ready()~ and benefit of using an anonymous function to contain all of jQuery code is that it creates function-level scope for its variables so it prevents naming collisions with other scripts that might use the same variable names
   - jQuery had a ~.load()~ method as it fired on the ~load~ event but this has been replaced by the ~.on()~ method, recall that the load event fires after the page and all of its resources have loaded so you should use this ~.on()~ method when your script relies on assets to have loaded (e.g. show dimensions of an image)
   - The ~.on()~ method works in all browsers and provides function-level scope for the variables it contains
   - jQuery's ~.ready()~ method checks if the browser supports the ~DOMContentLoaded~ event because it fires as soon as the DOM is loaded and it does not wait for other assets to finish loading making the page appear to load faster
   - jQuery will use an event listener for ~DOMContentLoaded~ if the browser supports it but in older browsers jQuery will wait for the ~load~ event to fire
   - If you were to place the script before the closing body tag then the HTML elements will have been loaded into DOM before your script runs but it is still common for people to use ~.ready()~ because it ensures no matter where the script is placed in the HTML the code will always run when the elements have been successfully loaded into DOM

** Section 7.9: Getting Element Content
   - The ~.html()~ and ~.text()~ methods both retrieve and update the content of elements
   - When ~.html()~ is used to retrieve info from a jQuery selection it retrieves only the HTML inside the first element in the matched set along with any of its descendants (so if the selection has child HTML elements, it will return all the HTML for that selection)
   - When ~.text()~ method is used to retrieve the text from a jQuery selection it returns the content from every element in the jQuery selection, along with the text from any descendants
   - ~.text()~ returns all of the text content of the selected elements as a single string with no HTML tags and no structure it is just concatenated text
   - ~.text()~ returns whitespace characters that are included inside the HTML elements but not the whitespace characters that separate the HTML elements (e.g. ~<li>Test \n New Line</li> <li>Test2</li>~ will return "Test \n New LineTest2" notice how the end of the first list item does not include space to the start of the next list item)
   - To get the content from ~<input>~ or ~<textarea>~ elements use the ~.val()~ method (more about it later)

** Section 7.10: Updating & Inserting Elements

*** Section 7.10.1: Updating Elements
    - There are four methods that update the content of all elements in a jQuery selection:
      - ~.html()~: Gives every elment in the matched set the same new content and the new content may include HTML
      - ~.text()~: Gives every element in the matched set the same new text content and any markup would be shown as text
      - ~.replaceWith()~: Replaces every element in a matched set with new content and it also returns the replaced elements (this method replaces the selected elements entirely with new content, either HTML, a DOM element, or another jQuery element and inserts the new content in their place keeping the same position in the DOM)
      - ~.remove()~: Removes all of the elements in the matched set
       
    - When the ~.html()~ and ~.text()~ methods are used as setters (to update content) they will replace the content of each element in the matched set along with any content and child elements
    - The ~.replaceWith()~ and ~.remove()~ methods replace and remove the elements they match as well as their content and any child elements
    - The ~.html()~ and ~.replaceWith()~ methods can take a string as a parameter and the string can be stored in a variable and contain markup while ~.text()~ also takes a string as a parameter but the markup would be treated as text
    - ~.remove()~ only has 1 optional parameter and that is a selector to filter which matched elements to remove
    - When you add markup to the DOM, be sure to escape all untrusted content properly on the server because both ~.html()~ and ~.replaceWith()~ methods carry the same security risks as using the DOM's ~innerHTML~ property
    - If you want to use and amend the content of the current selection, these methods can take a function as a parameter and then this function can be used to create new content
    - For example, if you want the existing html to be inside ~<em>~ tags so you take a function as an argument and in that function you return a new string with ~<em>~ tags but inside those tags will have the text of the element
    - To access the current element's properties and methods, you use ~$(this)~ and thus you can get the HTML or text by running ~$(this).text()~ or ~$(this).html()~ and place it in-between the ~<em>~ tags and return the string
    - So return indicates that the content should be returned by the function and replace the html, replace with, or replace the text and this refers to the current element so ~$(this)~ places that element in a new jQuery object so that you can use jQuery methods on it
    - Thus when updating the content of an element you can use a string, a variable, or a function

*** Section 7.10.2: Inserting Elements
    - Inserting new elements involves two steps:
      1. Create the new elements in a jQuery object
      2. Use a method to insert the content into the page
    - To create a new jQuery object you simply pass a string with markup into the ~jQuery()~ function
    - For example, ~$('<li>')~ creates an empty ~<li>~ element and stores it in a jQuery object
    - Another example, ~$('<li class="new">item</li>')~, this creates a jQuery object with a ~<li>~ element that has a class attribute and some text
    - Once you have a variable holding the new content, you can use the following methods to add the content to the DOM tree:
      - ~.before()~: Inserts content before the selected elements
      - ~.after()~: Inserts content after the selected elements
      - ~.prepend()~: Inserts content inside the selected elements after the opening tag
      - ~.append()~: Inserts content inside the selected elements before the closing tag
      - ~.prependTo()~: Inserts the selected elements inside the argument element after the opening tag
      - ~.appendTo()~: Inserts the selected elements inside the argument element after the closing tag
    - Thus you can create new jQuery objects to hold text and markup and then you can add the object to the DOM tree
    - If you create a selection that returns multiple elements then the methods above (~before()~, ~after()~, etc.) will add the same content to each of the elements in the matched set
    - When adding content to the DOM, make sure you have escaped all untrusted content properly on the server
      
** Section 7.11: Getting & Setting Attribute Values
   - You can create attributes or access and update their contents using the following four methods
     - ~.attr()~: This method can get or set a specified attribute and its value, to get the value of an attribute, you specify the name of the attribute as the argument (e.g. ~$('li').attr('id')~) and to update the value of an attribute you specify both the attribute name and its new value (e.g. ~$('li').attr('id', 'new-id')~)
     - ~.removeAttr()~: This method removes a specified attribute and its value, you specify the name of the attribute as an argument (e.g. ~$('li').removeAttr('id')~)
     - ~.addClass()~: This methods adds a new value to the existing value of the class attribute and it does not overwrite existing values
     - ~.removeClass()~: This method removes a value from the class attribute leaving any other class names within that attribute intact
   - You can work with any attribute on any element using ~attr()~ and ~removeAttr()~ methods
   - If you use the ~attr()~ method to update an attribute that does not exist then it will create the attribute and give it the specified value
   - The value of the ~class~ attribute can hold more than one class name each separated by a space
   - The ~addClass()~ and ~removeClass()~ methods are powerful because they let you add or remove an individual class name within the value of the class attribute and they do not affect any other class names

** Section 7.12: Getting & Setting CSS Properties
   - The ~.css()~ method lets you retrieve and set the values of CSS properties
   - To get the value of a CSS property, you indicate which property you want to retrieve in parentheses (e.g. ~$('li').css('background-color');~) and if the matched set contains more than element it will return the value from the first element
   - To set the values of a CSS property, you specify the property name as the first argument in the parentheses then a comma, followed by its value as the second argument (e.g. ~$(li).css('background-color', '#272727');~), this will update every element in the matched set
   - You can also specify multiple properties in the same method using object literal notation where properties and values are placed in curly braces, a colon is used to separate property names from their values, and a comma separates each pair (but there is not one after the last pair)
   - For example,
     
   #+BEGIN_SRC javascript
     $('li').css({
	 'background-color': '#272727',
	 'font-family': 'Courier'
     });
   #+END_SRC

   - When dealing with dimensions that are specified in pixels, you can increase and decreases the values using the ~+=~ and ~-=~ operators (e.g. ~$('li').css('padding-left', '+=20')~)
   - Note that it is better to change the value of a class attribute to trigger new CSS rules in the style sheet rather than to change CSS properties from within the JS file itself

** Section 7.13: Working with Every Element in a Selection
   - jQuery allows you to recreate the functionality of a loop on a selection of elements using the ~.each()~ method
   - Although there are many jQuery methods that update all of the elements in a matched set without the need for a loop, however, there are times when you want to loop through each of the elements in the section often because you are trying to get info from each element in the matched set or you want to perform a series of actions on each of the elements
   - The ~.each()~ method is provided for this purpose and the parameter of the ~.each()~ method is a function (an anonymous function or a named function)
   - ~.each()~ allows you to perform one or more statements on each of the items in the selection of elements that is returned by a selector
   - ~.each()~ takes one argument: a function containing the statements you want to run on each element (e.g. ~$('li').each(function() {})~
   - You first get the matched set by using ~$()~, you then call ~.each()~ to apply the same code to each element in the selection, and then the function is run for each of the items in the list
   - As the ~.each()~ method goes through the elements in a selection, you can access the current element using the ~this~ keyword and you will often see ~$(this)~ which uses the ~this~ keyword to create a new jQuery selection containing the current element allowing you to use jQuery methods on the current element
   - Note that you can access the current element using the keyword ~this~ and if you need to access properties of the node then it is better to use plain JS (more efficient) but if you need to use jQuery methods then that is when you create a jQuery object (~$(this)~)
   - Finally, ~.each()~ accepts a parameter, this parameter wil indicate the index of the element in the set, the matched set will be a zero-based index and thus it will start at 0 and go from there
     
** Section 7.14: Event Methods, Event Object, & Event Handlers
   - The ~.on()~ method is used to handle all events but behind the scenes jQuery handles all of the cross-browser issues seen in the previous chapter
   - Using the ~.on()~ method is no different than using any other jQuery method: you use a selector to create a jQuery selection and then you use the ~.on()~ to indicate which event you want to respond to and the function then adds an event listener to each element in the selection
   - ~.on()~ was introdcued in v1.7 of jQuery and prior to that jQuery would use separate methods for each event, e.g. ~.click()~, ~.focus()~, etc. but now ~.on()~ is only used
   - For example,

   #+BEGIN_SRC javascript
     $('li').on('click', function() {
	 $(this).addClass('complete');
     });
   #+END_SRC

   - In the example, we first get the selected items or matched set and then using the ~.on()~ method we specify, in the first argument, the event we want to respond to and the second argument we have the code we want to run when the event occurs on any element in the matched set
   - The function in the second argument can be a named function or an anonymous function
   - Almost all browsers events work with ~.on()~ and jQuery even has their own custom-built events like ~ready~ which is not a native DOM event but is a jQuery event that fires whenever the page is ready and ready to be worked with
   - You may be able to also specify multiple events in the 1st parameter which will fire the same function, you specify the events in the 1st parameter separated by a space in between them

   - Every event handling functions receives an ~event~ object and it has methods and properties to the event that occured
   - Just like the JS event object, the jQuery event object has properties and methods that tell you more about the event that took place
   - If you look at the function that is called when the event occurs, the event object is named in parentheses and this named is used within the function to refer the event object
   - For example,
     
   #+BEGIN_SRC javascript
     $('li').on('click', function(e) {
	 eventType = e.Type;
     });
   #+END_SRC

   - In the example above, we gave the event object a parameter name, we then use that name in the function to reference the event object, and then we can access the properties and methods of the object using the familiar dot notation (member operator)
   - Some properties include ~type~ (type of event, e.g. click, mouseover, etc.), ~which~ (button or key that was pressed), ~data~ (object literal containing extra info passed to the function), and more
   - Some methods include ~.preventDefault()~ and ~.stopPropagation()~, and more

   - The ~.on()~ method has two optional properties that let you: (1) filter the matched set to only respond to events that happend on a set of elements and (2) pass extra info into the event handler using object literal notation
   - The actual syntax of the ~.on()~ method is as follows:

   #+BEGIN_SRC javascript
     .on(events [, selector] [, data], function(e));
   #+END_SRC

   - The first argument is the event you want to respond to and if you want to respond to more than one event then you can provide a space-separated list of event names (e.g. 'focus click')
   - The second argument is optional and this allows you to further filter the matched set to only respond to the event happening on a subset of the initial jQuery selection, this was great for event delegation because now you can filter its descendants as well and event handlers would be for the ancestor but listen on its descendants thus having event delegation
   - The third argument is also optional and you can pass extra info to the function that is called when the event is triggered and the info is passed along with the event object
   - So the third argument takes in an object literal and you can access that info via the event object (~e.data~) and access the properties in the object literal by using the dot operator and using the same name in ~e.data~ as in the object literal
   - The fourth argument is the function that should be run when the specified events occur on one of the elements in the matched set (or filtered matched set)
   - And finally, the event object is automatically passed to the function but in order to use it you must give the function a parameter name for the event object
   - Before jQuery v1.7 the ~.delegate()~ function would be used to add event handlers for the parent and listen to the events on the child but was replaced since v1.7+ with ~.on()~

** Section 7.15: Animation
   - When you start using jQuery, the effects methods can enhance your web page with transitions and movement
   - With jQuery you can make content animate fading in and out, slide them up and down, or hide them or show them
   - When an element that was previously hidden is shown, faded in, or slides into view, the other elements on the page may move to make space for it
   - When an element is hidden, has been faded out, or has slid out of view, the other elements on the page can move into the space these elements took up
   - Methods with ~toggle~ in their name will look at the current state of the element (whether it is visible or hidden) and will switch to the opposite state
   - However, most of these animations can be done in CSS and it best to use CSS for animations because it is faster than jQuery

   | Method           | Description                                                                                             |
   |------------------+---------------------------------------------------------------------------------------------------------|
   | ~.show()~        | Displays selected elements                                                                              |
   | ~.hide()~        | Hides selected elements                                                                                 |
   | ~.toggle()~      | Toggles between showing and hiding selected elements                                                    |
   | ~.fadeIn()~      | Fades in selected elements making them opaque                                                           |
   | ~.fadeOut()~     | Fades out selected elements making them transparent                                                     |
   | ~.fadeTo()~      | Changes opacity of selected elements                                                                    |
   | ~.fadeToggle()~  | Hides or shows selected elements by changing their opacity (the opposite of their current state)        |
   | ~.slideUp()~     | Hides selected elements with a sliding motion                                                           |
   | ~.slideDown()~   | Shows selected elements with a sliding motion                                                           |
   | ~.slideToggle()~ | Hides or shows selected elements with a sliding motion (in the opposite direction to its current state) |
   | ~.delay()~       | Delays execution of subsequent items in queue                                                           |
   | ~.stop()~        | Stops an animation if it is currently running                                                           |
   | ~.animate()~     | Creates custom animations                                                                               |

   - The ~.animate()~ method allows you to create some of your own effects and animations by changing CSS properties
   - You can animate any CSS property whose value can be represented as a number (e.g. height, width, font-size, etc.) but not those whose value would be a string (e.g. font-family, text-transform, etc.)
   - CSS properties inside the method is written using camelCase notation so the first word is all lowercase and each subsequent word starts with an uppercase character (e.g. ~border-top-left-radius~ would become ~borderTopLeftRadius~)
   - The ~.animate()~ function accepts 4 arguments, the first argument is the object literal and then 3 optional arguments
   - The CSS properties are specified in the object literal (e.g. ~{opacity: 0.0}~)
   - After the second argument is optional and it is the speed parameter which indicates the duration of the animation in milliseconds (it can also take the keywords "slow" and "fast")
   - The third argument is optional and it is the easing parameter, it can have two values: "linear" (the speed of animation is uniform) or "swing" (speeds up in the middle of the transition and is slower at the start and end) and if no value is specified then "swing" is used by default
   - The fourth argument is optional and it is called complete, it is used to call a function that should run when the animation has finished, this is known as a callback function, so it can be a named function or an anonymous function
   - For example,

   #+BEGIN_SRC javascript
     $('li').on('click', function(){ // add event handler when list item is clicked
	 $(this).animate({ // animate list item
	     opacity: 0.0, // make it disappear
	     paddingLeft: '+=80' // make it move to right like if it is leaving
	 }, 500, 'swing', function(){ // when animation finished actually remove the list item from DOM
	     $(this).remove();    
	 });
     });
   #+END_SRC

   - To animate between two colors, rather than using ~.animate()~ method you can instead use the jQuery's jQuery-color plugin

** Section 7.16: Traversing the DOM
   - When you have made a jQuery selection, you can use these methods to access other element nodes relative to the initial selection

   | Method         | Selector | Description                                               |
   |----------------+----------+-----------------------------------------------------------|
   | ~.find(<>)~    | Required | All elements within current selection that match selector |
   | ~.closest(<>)~ | Required | Nearest ancestor (not just parent) that matches selector  |
   | ~.parent()~    | Optional | Direct parent of current selection                        |
   | ~.parents()~   | Optional | All parents of current selection                          |
   | ~.children()~  | Optional | All children of current selection                         |
   | ~.siblings()~  | Optional | All siblings of current selection                         |
   | ~.next()~      | Optional | Next sibling of current element                           |
   | ~.nextAll()~   | Optional | All subsequent siblings of current element                |
   | ~.prev()~      | Optional | Previous sibling of current element                       |
   | ~.prevAll()~   | Optional | All previous siblings of current element                  |

   - Each method finds elements that have a different relationship to those that are in the current selection (e.g., parents or children of the current selection)
   - The ~.find()~ and ~.closest()~ methods both require a CSS-style selector as an argument while the other methods the CSS-style selector is optional
   - But if a selector is provided, both the method and selector must match in order for the element to be added to the new selection
   - For example, if you start with a selection that contains one list item, you could create a new selection containing the other items from the list using the ~.siblings()~ method
   - If you added a selector into the method such as this: ~.siblings('.important')~ then it would find only siblings with a class attribute whose value included "important"
   - If the original selection contains multiple elements, these methods all work on all of the elements in the selection (which can result in quite an odd selection of elements) so you may need to narrow down your initial selection before traversing the DOM
   - Behind the scenes, jQuery will handle the cross-browser inconsistencies involved in traversing the DOM 9such as whitespace nodes being added by some browsers)

** Section 7.17: Add & Filtering Elements in a Selection
   - Once you have a jQuery selection, you can add more elements to it or you can filter the selection to work with a subset of the elements

   | Method / Selector   | Description                                                                                                     |
   |---------------------+-----------------------------------------------------------------------------------------------------------------|
   | ~.add()~            | Adds new content to the items in the existing selection and places the resulting content in a new jQuery object |
   | ~.filter()~         | Finds elements in the matched set that in turn match a second selector                                          |
   | ~.find()~           | Finds descendants of elements in the matched set that match a selector                                          |
   | ~.not()~ / ~:not()~ | Finds elements that do not match the selector                                                                   |
   | ~.has()~ / ~:has()~ | Finds elements from the matched set that have a descendant that matches the selector                            |
   | ~:contains()~       | Selects all elements that contain the text specified (parameter is case sensitive)                              |
   | ~.is()~             | Checks whether current selection matches a condition (returns boolean)                                          |

   - Note that ~$('li').not('.hot').addClass('cool')~ is equivalent to ~$('li:not(.hot)').addClass('cool')~
   - The ~.add()~ method allows you to add a new selection to an existing one
   - The functions take a selector as a parameter and either add to your existing matched set, find a new matched set, or filters the matched set
   - The items that begin with a colon can be used wherever you would use a CSS-style selector, so in the selector you append the colon and function name along with any additional selector
   - The ~:not()~ and ~:has()~ selectors take another CSS-style selector as a parameter and the ~:contains()~ lets you find elements that contain specific text
   - The ~:is()~ method lets you use another selector to check whether the current selection matches a condition and if it does then it will return true otherwise it will return false (this is helpful in conditional statements)

** Section 7.18: Finding Items by Order
   - Each item returned by a jQuery selector is given an index number which can be used to filter the selection
   - The jQuery object is sometimes referred to as being an array-like object because it assigns a number to each of the elements that is returned by a selector
   - That number is an index number which means it starts at 0
   - You can filter the selected elements based on this number using methods or these additional CSS-style selectors that jQuery has added
   - Methods are applied to the jQuery selection, whereas selectors are used as part of the CSS-style selector
   - For example, if you run ~$('li')~, each list item that is returned to a jQuery object will have index starting from zero, so if you run ~$('li').eq(2)~ it will get the list item with an index of 2, if you run ~$('li:lt(2)')~ then it will get list items with an index less than 2
   
   | Method / Selector | Description                                              |
   |-------------------+----------------------------------------------------------|
   | ~.eq()~           | The element that matches the index number                |
   | ~:lt()~           | Elements with an inde less than the number specified     |
   | ~:gt()~           | Elements with an index greater than the number specified |

** Section 7.19: Working with Forms
   - jQuery has selectors that are designed specifically to work with forms, however, they are not always the quickest way to select elements
   - Selectors for Form Elements:

   | Selector    | Description                                                                                                                                                                 |
   |-------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~:button~   | ~<button>~ and ~<input>~ eleemnts whose ~type~ attribute has a value of button                                                                                              |
   | ~:checkbox~ | ~<input>~ elements whose ~type~ attribute has a value of ~checkbox~ (note that you might get better performance with ~$('[type="checkbox"]')~                               |
   | ~:checked~  | Checked elements from checkboxes and radio buttons (see ~:selected~ for select boxes)                                                                                       |
   | ~:disabled~ | All elements that have been disabled                                                                                                                                        |
   | ~:enabled~  | All elements that are enabled                                                                                                                                               |
   | ~:focus~    | Element that currently has focus (note that you can get better performance with ~$(document.activeElement)~                                                                 |
   | ~:file~     | All elements that are file inputs                                                                                                                                           |
   | ~:image~    | All image inputs (note that you get better performance with ~[type="image"]~                                                                                                |
   | ~:input~    | All ~<button>~, ~<input>~, ~<selector>~, and ~<textarea>~ elements (note that you get better performance from selecting elements then using ~.filter(":input")~             |
   | ~:password~ | All password inputs (note that you get better performance using ~$('input:password')~                                                                                       |
   | ~:radio~    | All radio inputs (to select a group of radio buttons you can use ~$('input[name="gender"]:radio')~                                                                          |
   | ~:reset~    | All inputs that are reset buttons                                                                                                                                           |
   | ~:selected~ | All elements that are selected (note that you get better performance using a CSS selector inside the ~.filter()~ method, e.g. ~.filter(":selected")~                        |
   | ~:submit~   | ~<button>~ and ~<input>~ elements whose ~type~ attribute has a value of ~submit~ (note that you will get better performance using ~[type="submit"]~                         |
   | ~:text~     | Selects ~<input>~ elements with a ~type~ attribute whose value is text or whose type attribute is not present (you will likely get better performance from ~('input:text')~ |

   - If you use one of these selectors on its own, jQuery will examine each element in the document to find a match, thus it will use jQuery code which is not as fast as CSS selectors
   - Therefore, you should narrow down the part of the document the script needs to look through by placing an element name or other jQuery selector before using the selectors shown in the table above
   - You can also access elements in a form using the same selectors used to pick any element in jQuery (this option could be faster)
   - Because jQuery handles whitespace nodes for you, it is easy to traverse between form elements using jQuery compared to using plain JS
   - Other methods:

   | Method          | Description                                                                                                                                                                    |
   |-----------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~.val()~        | Primarily used with ~<input>~, ~<select>~, and ~<textarea>~ elements, it can be used to get the value of the first element in a matched set or update the value of all of them |
   | ~.filter()~     | Used to filter a jQuery selection using a second selector (espeically form-specific filters)                                                                                   |
   | ~.is()~         | Often used with filters to check whether a form input is selected / checked                                                                                                    |
   | ~$.isNumeric()~ | Checks whether the value represents a numeric value and returns a boolean (e.g. ~$.isNumeric("2")~, ~$.isNumeric(+2)~, ~$.isNumeric(4.4)~, ~$.isNumeric(0xFF)~, etc.)          |

   - The ~.val()~ method gets the value of the first ~<input>~, ~<select>~, or ~<textarea>~ element in a jQuery selection and it can also be used to set the value for all matching elements
   - The ~.filter()~ and ~.is()~ methods are commonly used with form elements and we discussed these methods previously
   - The ~$.isNumeric()~ is a global method and it is not used on a jQuery selection but rather the value you want to test is passed as an argument
   - Events (works with the method ~.on()~):

   | Events   | Description                                         |
   |----------+-----------------------------------------------------|
   | ~blur~   | When an element loses focus                         |
   | ~change~ | When the value of an input changes                  |
   | ~focus~  | When an element gains focus                         |
   | ~select~ | When the option for a ~<select>~ element is changed |
   | ~submit~ | When a form is submitted                            |
   
   - These events correspond to JS events that you might use to trigger functions, as with other jQuery code, jQuery handles any inconsistencies between browsers when dealing with these events
   - jQuery also makes it easier to work with a group of elements such as radio buttons, checkboxes, and the options in a select box because once you have selected the elements you can simply apply individual methods to each of them without having to write a loop
   - When submitting a form there is also a helpfu method called ~.serialize()~ which we will learn more about later

** Section 7.20: Cutting & Copying Elements
   - Once you have a jQuery selection, you can use these methods to remove those elements or make a copy of them

   | Method      | Description                                                                                                                                                                                                                                                                                              |
   |-------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~.remove()~ | Removes matched elements from DOM tree (including any descendants and text nodes)                                                                                                                                                                                                                        |
   | ~.detach()~ | Same as ~.remove()~ but keeps a copy of them in memory                                                                                                                                                                                                                                                   |
   | ~.empty()~  | Removes child nodes and descendants from any elements in matched set (child data and event handlers are also removed)                                                                                                                                                                                    |
   | ~.unwrap()~ | Removes parents of matched set, leaving matched elements, and now the grandparent becomes the new parent of the matched elements (while the old parent is removed along with any data and event handlers)                                                                                                |
   | ~.clone()~  | Creates a copy of the matched set (including any descendants and text nodes), by default clone does not copy data or event handlers (you must specify true in the argument if you want that), and the clone is not automatically added to DOM, you must also added it to DOM if you want it to be in DOM |

   - The ~.remove()~ method deletes the matched elements and all of their descendants from the DOM tree
   - The ~.detach()~ method also removes the matched elements and all of their descendants from the DOM tree; however, it retains any event handlers and any other associated jQuery data so they can be inserted back into the page
   - The ~.empty()~ (remove children) and ~.unwrap()~ (remove parent) methods remove elements in relation to the current selection
   - The ~.clone()~ method creates a copy of the matched set of elements and any descendants and if you use this method on elements that have an id attribute then you will need to update the id attribute otherwise it would no longer be unique (if you want event handlers to be cloned too then you should add true as an argument to clone)

** Section 7.21: Dimensions

*** Section 7.21.1: Box Dimensions
    | Method               | Retrieve or Set | Description                                      |
    |----------------------+-----------------+--------------------------------------------------|
    | ~.height()~          | Both            | Height of box (no margin, no border, no padding) |
    | ~.width()~           | Both            | Width of box (no margin, no border, no padding)  |
    | ~.innerHeight()~     | Retrieve        | Height of box plus padding                       |
    | ~.innerWidth()~      | Retrieve        | Width of box plus padding                        |
    | ~.outerHeight()~     | Retrieve        | Height of box plus padding and border            |
    | ~.outerWidth()~      | Retrieve        | Width of box plus padding and border             |
    | ~.outerHeight(true)~ | Retrieve        | Height of box plus padding, border, and margin   |
    | ~.outerWidth(true)~  | Retrieve        | Width of box plus padding, border, and margin    |
   
    - The methods above allow you to discover or update the width and height of all boxes on the page
    - CSS treats each element on a web page as if it were in its own box and a box can have padding, a border, and a margin
    - If you set the width or height of the box in CSS, it does not include any padding, border, or margin - they are added to the dimensions
    - The methods above allow you to retrieve the width and height of the first element in the matched set and the first two methods shown above allow you to update the dimensions of all boxes in the matched set
    - The other methods give you different measurements depending on whether you want to include padding, border. and margin
    - ~.outerHeight()~ and ~.outerWidth()~ take a parameter of true if you want the margin included
    - When retrieving the dimensions these methods return a number in pixels
    - You can use percentages when setting the dimensions but keep in mind percentage widths are always relative to the parent’s width (not the previous width of the element)
    - Measurements in percentages or ems should be given as a string with the suffix '%' or 'em' but pixels do not require a suffix and are not enclosed in quotes

*** Section 7.21.2: Window & Page Dimensions
    | Method          | Description                                                                                                                                                                                                         |
    |-----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | ~.height()~     | Height of the jQuery selection                                                                                                                                                                                      |
    | ~.width()~      | Width of the jQuery selection                                                                                                                                                                                       |
    | ~.scrollLeft()~ | Gets the horizontal position of the scroll bar for the first element in the jQuery selection or sets the horizontal scroll bar position for matched nodes                                                           |
    | ~.scrollTop()~  | Gets the vertical position of the scroll bar for the first element in the jQuery selection or sets the vertical scroll bar position ofr matched nodes                                                               |
    | ~.offset()~     | Gets or sets coordinates of the element relative to the top left-hand corner of the ~document~ object                                                                                                               |
    | ~.position()~   | Gets or sets coordinates of the element relative to any ancestor that has been take out of normal flow (using CSS box offsets) and if no ancestor is out of normal flow then it will return the same as ~.offset()~ |

    - ~.height()~ and ~.width()~ can also be used on a jQuery selection containing the ~window~ or ~document~ objects
    - The browser can display scroll bars if the height or width of a box's content is larger than its allocated space or the current page represented by the document object is larger than the dimensions of the browser window's viewable area (viewport)
    - The ~.scrollLeft()~ and ~.scrollTop()~ methods allow you to get and set the position of the scroll bars
    - When retrieving dimensions, these methods return a number in pixels
    - The ~.offset()~ and ~.position()~ methods can be used to determine the position of elements on the page, it helps to determine the position of the an element: within the page and in relation to an ancestor that is offset from normal flow
    - ~.offset()~ and ~.position()~ returns an object that has two properties: ~top~ (position from the top of the document or containing element) and ~left~ (position from the left of the document or containing element)
    - As with other jQuery methods, when used to retrieve information, they return the co-ordinates of the first element in the matched set
    - If they are used to set the position of elements, they will update the position of all elements in the matched set (putting them in the same spot)
    - To get the offset or position, store the object that is returned by these methods in a variable and then use the ~left~ or ~top~ properties of the object to retrieve their position

** Section 7.22: Ways to Include jQuery
   - In addition to hosting the jQuery file with the rest of your website, you can also use a version that is hosted by other companies however it is good to still include a fallback version if the original file fails to load
   - A content delivery network (CDN) is a series of servers spread out around the world to serve static files (such as HTML, CSS, JS, images, audio, video, etc.) quickly
   - CDN tries to find the server nearest to you and then sends the files from that server so the data does not travel far and take a lot of time
   - When including jQuery in your pages, you can try to load it from one of these CDNs and then check if it is loaded and if not you can include a version that is stored on your own server (as a fallback)
   - This is outdated, but before, protocol relative URL is when you omit the protocol when specifying a URL so instead of ~https://www.google.com~ we can do ~//www.google.com~ with only two forward slashes
   - This lets the browser know of protocol relative URL which tells it to use the same protocol as the current page either HTTP or HTTPS
   - This was helpful back in the day because you can make your resources (images, scripts, etc.) work on both HTTP or HTTPS without mixing content and not hardcoding the protocol
   - However that is outdated since we have now since defaulted to HTTPS and we should always use HTTPS in releases
   - After loading the jQuery file from a CDN, we then add another small script to check if ~window.jQuery~ returns true otherwise you the load and use your local file

*** Section 7.22.1: Where to Place Your Script
    - The position of ~<script>~ elements can affect how quickly a web page seems to load
    - In the early days, developers were told to place the scripts in the ~<head>~ of the page however this can make the pages seem slower to load (because it waits for the script to load and then loads whatever is after which is the ~<body>~)
    - Your web page may use files from several different servers and locations, and usually a browser will collect up to two files at a time from each different server, but when a browser starts to download a JS file it stops all other downloads and pauses laying out the page until the script has finished loading and been processed
    - Thus if you place the script at the end of the page before closing ~</body>~ tag it will not affect the rendering of the rest of the page (now in modern browsers there are new ways to not prevent the browser from rendering)
    - If the script tries to access an element before it has loaded, it causes an error
    - Where possible do consider using alternatives to scripts, so instead of using JS for animations try to use CSS for animations, instead of trying to modify CSS with JS, create attributes in HTML, add some CSS properties, and toggle them in JS
    - Let JS be the last resort and try to use less JS
    - If you place a script tag in the head (without using any newer techniques) it may load your page slowly and at that time DOM won't be loaded so you will need to add an event listener like ~load~ or ~DOMContentLoaded~ to trigger the rest of the script
    - If you need to use it in the ~<head>~ the script tag should be just before the closing ~</head>~ tag
    - This is also the case if you put the script inside the body, it may slow down the page (due to the script loading), and the rest of the body (after the script) will still not be loaded
    - Without using any new techniques the best place is before the ~</body>~ tag because everything would have been loaded and rendered so it won't block anything because most of it, if not all, has been loaded including the DOM so no event handler is needed

** Section 7.23: jQuery Documentation & More
   - For jQuery documentation we can visit: https://api.jquery.com
   - The documentation site lists each method and property available to use along with any new functionality or deprecated functionality added to the latest versions
   - jQuery has hundreds of plugins and these plugins are scripts that extend the functionality of the jQuery library (basically plugins offer functionality that is not included in the jQuery library)
   - To view the old plugins (which most are not being actively developed no more) visit https://plugins.jquery.com
   - jQuery is an example of what programmers call a JS library, it is a JS file that you can include in your page which then lets you use the functions, objects, methods, and properties it contains
   - The concept of a library is that you can "borrow" or use its code (functions, objects, methods, and properties) from one file in another script
   - The problem with libraries is that it may contain code that you might not need so it adds bloat to your website causing your website to be slower so you can either strip down the library or write your own lite library
   - If you use multiple libraries then take into consideration that ~$()~ might be used by multiple libraries (e.g. jQuery and prototype.js) so we have to try our best to avoid conflicts
   - One way is to include jQuery library after other libraries in HTML (thus jQuery's ~$~ will take precedence) and you use the jQuery method ~.noConflict()~ at the start of the script which tells jQuery to release ~$~ shortcut so that other scripts can use it then you use the full name rather than the shortcut
   - You can also wrap your script with jQuery in an IIFE (immediately invoked function expression) and still use ~$~ or you can specify your own alias instead of ~$()~
   - Another way is to include jQuery before other libraries (thus the other libraries' ~$~ will take precedence) and ~$~ will have the meaning defined in the other library so there is no need to call ~.noConflict()~ because it will have no effect but then you *have* to continue to use the full function name ~jQuery()~ because ~$~ is already taken by the other libraries
   - You can create a scoped alias ~$~ inside the ~.ready()~ method by passing the ~$~ as an argument to the anonymous function called by the ~.ready()~ method so now inside the anonymous function ~$~ can be used instead of ~jQuery()~ because the alias has a scope and there is also scope precedence

** Section 7.24: Chapter Exercise
   - We are going to create another TODO list app but now using jQuery
   - Here are the requirements:
     1. There is a single tab with active and completed items
     2. The heading must specify the amount of "active" items
     3. The user can click on a button called "new item" which will make a form appear to add a new item (animate the new item to the top of the list)
     4. Once a new item has been added the form will disappear and "new item" button will reappear
     5. Users can click on an active item to mark as complete which will move the item to the bottom of the list and change the background color
     6. Users can click on a completed item to remove it from the list
     7. Use event delegation when clicking on the list items (if active then move to the bottom of list, update counter, and mark it as complete, if complete then fade it out and remove it from the list)
   - [[file:./007.024.Chapter_Exercise/index.html][Here is the chapter exercise]]

** Section 7.25: Summary
   - jQuery is a JS file you include in your website
   - Once included, it makes it faster and easier to write cross-browser JS based on two steps:
     1. Using CSS-style selectors to collect one or more nodes from the DOM tree
     2. Using jQuery's built-in methods to work with the elements in that selection
   - jQuery's CSS-style selector syntax makes it easier to select elements to work with and it also has methods that make it easier to traverse the DOM
   - jQuery makes it easier to handle events because the event methods work across all browsers
   - jQuery offers methods that make it quick and simple to achieve a range of tasks that JS programmers commonly need to perform
   
* Keywords
| Term   | Definition |
|--------+------------|
| jQuery | jQuery is an open-source JavaScript library, and in addition, jQuery is the name of the function that accepts a string containing a CSS selector which returns a jQuery object with the matched set |

* Questions
  - *Q*: How is ~$()~ shorthand for ~jQuery()~?
         - ~$()~ works because ~$~ is an alias for ~jQuery()~
	 - jQuery assigns its main function to ~$~ because ~$~ is a valid variable or function name
	 - For example, somewhere in the code it does the following: ~var $ = jQuery~
	 - Of course it doesn't use the parentheses because it is not invoking it just yet
	 - Thus we do add the parentheses to ~$~ then you get ~$()~ and that is the function being invoked
	 - So if you were to override ~$~ to a different value then ~$()~ would no longer work
	 - In the end, ~$~ is a variable (alias) for the function called ~jQuery~

  - *Q*: Does the ~$().on()~ function accept anonymous functions and named functions?
         - Yes they accept anonymous functions and they also accepted named functions
	 - Both anonymous functions and named functions also accept the event object inside the ~on()~ jQuery method

  - *Q*: What is the difference between ~.filter()~, ~.find()~, and ~.has()~?
         - ~.filter()~ filters the matched set it does not check the descendants of the matched set
	 - For example, let's say we have a list and we get the list items ~$('li')~ so we run ~.filter('.someClass')~ it will filter the list items to only the list items with that class name
	 - If the list items have children with that class it will *not* get them because filter only "filters" out the matched set not the descendants
	 - ~.find()~ finds the elements that match the selector in its descendants
	 - ~.find()~ does not try to match the selector with the matched set because that is not the purpose of the function instead it only looks at the match set's descendants
	 - For example, let's say we get the list items and only the list items have a specific class and we run ~$('li').find('.someClass')~ then it will return an empty jQuery object
	 - Now let's say along with the list items some of its children have the same class so now ~$('li').find('.someClass')~ will return a jQuery object with only the elements in its descendants (children) with that class (not the list items themselves)
	 - So ~.filter()~ "filters" out the matched set only by using the selector while ~.find()~ will "find" the elements in its descendants of the matched set using the selector
	 - ~.has()~ is another filter but now it filter based on the descendants have the selector
	 - If so, then the matching set will be kept
	 - For example, if we run ~$('li').has('.someClass')~ then it will keep any list items that have a descendant with the class "someClass" while find will return the descendant elements with that class
	 - So ~.has()~ filters the matched set based on the selector matching its descendants while ~.find()~ will find the descendants of the matched set matching the selector

  - *Q*: What is the difference between ~.remove()~ and ~.detach()~
         - ~.remove()~ removes the selected elements from the DOM and also removes all associated data and event handlers (anything added with ~.on()~ or ~.data()~)
	 - ~.remove()~ is used when you completely want to remove it from the DOM and do not plan on it using it again
	 - ~.detach()~ also removes selected elements from the DOM but preserves all data and event handlers associated with the elements
	 - ~.detach()~ is used whenever you need to temporary remove your element but insert the element at a later time
	 - Thus ~.detach()~ disappears from DOM but keeps it data so whenever you add back to DOM everything still works as before (events and data are still intact)
    
* Summary
  - jQuery offers a simple way to achieve a variety of common JS tasks quickly and consistently across all major browsers (e.g. add classes to a matched set, get / set attributes, etc.)
  - *Note*: jQuery is an outdated library but at the time running common tasks was cumbersome and there were discrepancies between browsers so jQuery was very convenient having a function to handle everything for you but now WHATWG has standardize features between all browsers and has added browser APIs that achieve the same thing as jQuery so now there is no need for jQuery because now it can achieved with plain JS
  - However, let's continue, jQuery is a JS file that you include in your web pages and it helps you find elements using CSS-style selectors and then you can do some task on the matched set using the jQuery methods
  - To get the matched set you call the function ~jQuery()~ or ~$()~ (short-hand) and for the argument you pass in a CSS selector and the function will return a jQuery object and inside the object it will hold references (it points to the nodes already in memory in the DOM) to the elements that matched the CSS selector
  - You can then store the jQuery object in a variable and use its properties or call on further methods
  - When you are going to use a match set multiple times it is best to store the jQuery object in a variable because using ~jQuery()~ everytime will use unnecessary resources
  - In addition, jQuery offers additional selectors to offer greater functionality (e.g. get every ~li~ but only that has an index greater than 3)
  - You can use CSS syntax, in addition to the jQuery selectors (see section 7.4), to find matching elements and return a matched set (a jQuery object)
  - Once you get a jQuery object you have many methods avaiable to you, these methods can find or change content of elements, attributes, and text nodes, traverse the DOM, find descendant elements, get dimensions, add animations, or add event listeners
  - Some of jQuery methods return info, update contents, but not all can applied to all elements, some work with some elements while others do not
  - It is best to look at documentation to see what the method does, what it does it return, and which elements it works on: https://api.jquery.com
  - The jQuery object that is returned from the function ~jQuery()~ does not actually return copies of the elements but holds references to the elements in the DOM tree
  - Many of the methods from the jQuery object apply to all elements in the jQuery object which is convenient because you do not need a loop and with jQuery you can call methods after another thus "chaining" the methods 
  - The methods that retrieve info cannot be used to retrieve the info on elements, when wanting to retrieve info from all elements in the matched set you will need to call ~.each()~ but all other methods work for all elements
  - There are many methods in jQuery, for example the ~.ready()~ function (~$(document.ready(function() {});~ or ~$(function() {});~) checks that the page is ready for your code to work with instead of having to deal with adding event listeners yourself
  - There are methods like ~.html()~ to get and set the HTML, ~.text()~ to get or set the text, ~.replaceWith()~ which replaces every element in a matched set, and ~.remove()~ that removes the elements in the matched set
  - You can also create new jQuery objects like ~$('<li class="new">item</li>')~ with a string that includes markup and then using this new object (or any detached element) you can insert it by using ~.before()~, ~.after()~, ~.prepend()~, ~.append()~, ~.preprendTo()~, and ~.appendTo()~
  - Other functions can be used to get, set, and remove attributes, classes, and CSS properties
  - You can iterate the matched set using the ~.each()~ function and give it a function (named or anonymous) and inside the function use the keyword ~this~ to access the current element in the matched set (we can then get the element in a jQuery object ~$(this)~)
  - In jQuery you can add event listeners using the ~.on()~ function, specify an event, and specify a function with a parameter name for the event object
  - jQuery will pass an event object to your function and you can get the origianting element that fired the element using ~event.target~ and this can be used for event delegation
  - jQuery has methods for animations and traversing the DOM as well
  - jQuery also has methods to filter the matched set or find elements within the descendants of the matched set, and you can event filter selections based on their indices
  - Every element has an index, so if you do for example ~$('li:gt(3)')~ then every list item will get an index and you want to get the list items that have an index that is greater than 3
  - jQuery has methods to filter or add to the selector a filter based on indices
  - jQuey has also methods and selectors specifically to work with forms
  - jQuery has methods to remove elements (and delete all its data and event listeners) from the DOM tree, or just remove from the DOM tree (but keep its data and event listeners) so it can be added later to the DOM, and has a method to clone elements
  - jQuery also has methods to get different dimensions of elements, get dimensions of the window, or get the dimensions of the document
  - To get the jQuery file you can download the file from their website and add it to your own website or you can include it from own of their servers by using the ~<script>~ tag and the source attribute being the address to the server containing the jQuery file
  - The best place to add JS scripts might be at the end of the the body right before ~</body>~ because by the time the browser reaches the script everything will have been loaded on the screen and in the DOM but you can also add it to the ~<head>~ if you use an event listener (to check for DOM to be ready) or you newer techniques to make your JS file non-blocking so it can continue to render HTML content to the user
  - Their website https://jquery.com is the best place for any questions and documentation for jQuery
