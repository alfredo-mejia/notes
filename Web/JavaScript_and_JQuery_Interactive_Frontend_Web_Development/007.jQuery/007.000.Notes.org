#+title: Chapter 7: Query
#+author: Alfredo Mejia
#+options: num:nil html-postamble:nil
#+html_head: <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css" /> <style>body {margin: 5%} h1,h2,h3,h4,h5,h6 {margin-top: 3%} .content ul:not(:first-child) {margin-top: 0.25em}}</style>

* Navigation
| Nav   | Title                                                       | Links                                   |
|-------+-------------------------------------------------------------+-----------------------------------------|
| Index | Notes Home                                                  | \vert [[file:../../../index.html][html]] \vert [[file:../../../index.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main][github]] \vert |
| Home  | JavaScript & JQuery - Interactive Front-end Web Development | \vert [[file:../000.Home.html][html]] \vert [[file:../000.Home.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development][github]] \vert |
| Prev  | Chapter 6: Events                                           | \vert [[file:../006.Events/006.000.Notes.html][html]] \vert [[file:../006.Events/006.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/006.Events][github]] \vert |
| Next  | Chapter 8: AJAX & JSON                                      | \vert [[file:../008.Ajax_and_JSON/008.000.Notes.html][html]] \vert [[file:../008.Ajax_and_JSON/008.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/008.Ajax_and_JSON][github]] \vert |

* Notes

** Section 7.1: Introduction
   - jQuery offers a simple way to achieve a variety of common JavaScript tasks quickly and consistently across all major browsers and without any fallback code needed
   - It is simpler to access elements using jQuery's CSS-style selectors than it is using DOM queries (the selectors are more flexible and powerful)
   - jQuery's methods let you update the DOM tree, animate elements into and out of view, and loop through a set of elements, all in one line of code
   - jQuery includes methods that allow you to attach event listeners to selected elements without having to write any fallback code to support older browsers
     
** Section 7.2: What is jQuery?
   - jQuery is a JS file that you include in your web pages
   - jQuery lets you find elements using CSS-style selectors and then do something with the elements using jQuery methods

*** Section 7.2.1: Finding Elements using CSS-Style Selectors
    - A function called ~jQuery()~ lets you find one or more elements in the page
    - This function creates an object called ~jQuery~ which holds references to those elements
    - ~$()~ is often as a shorthand to save typing ~jQuery()~
    - Example, let's say we have a link called "existing" and we run ~jQuery("a.existing")~ then it will return an object with the references to those elements
    - The ~jQuery()~ function has one parameter: a CSS-style selector
    - ~jQuery~ selectors perform similar task to traditional DOM queries but syntax is much simpler because all you need to do is ~$()~
    - You can store the ~jQuery~ object in a variable, just like DOM nodes, and the ~jQuery~ object has methods and properties to manipulate the DOM nodes that you have selected just like DOM properties and methods

*** Section 7.2.2: Do SOmething with Elements using jQuery Methods
    - ~jQuery~ object has many methods that you can use to work with the elements you select, these methods represent tasks that you commonly need to perform with elements
    - After using ~jQuery()~ the object and the elements it contains is referred to as a *matched set* or a *jQuery selection*
    - You can then use the methods of the ~jQuery~ object to update the elements it contains
    - For example, the method ~$().addClass()~ adds a new value to the class attribute for all the elements selected (the matched set)
    - The differences from DOM is that jQuery is corss-browser and does not need to have fallback code
    - Thus selecting elements is simpler (also due to CSS-style syntax and the shorthand of the method ~jQuery()~), add event handlers is also simple because it is cross-browser, methods affect all elements in the matched set without a need of the loop, additional methods are provided for animation, and once you have a set of elements you can apply multiple methods to it

*** Section 7.2.3: A jQuery Example
    - To use jQuery you need to include the jQuery script into your web page
    - Once jQuery is added you can then import your own JS file that would be using jQuery
    - Many people using jQuery use the minified file of jQuery so it ends with the extension ~.min.js~
    - This file went through a process called minification which involves unnecessary spaces, carriage returns, comments being stripped from the code, and optimizations to make the file smaller and faster to load (although minified files are hard to read)
    - You do not need to understand the jQuery code, all you need to know is how to select elements and use its methods and properties
    - Example:

    #+BEGIN_SRC javascript
      $(":header").addClass("headline");
      $("li:lt(3)").hide().fadeIn(1500);
      $("li").on("click", function(){ $(this).remove(); });
    #+END_SRC

    - The first line selects all of the ~<h1> - <h6>~ headings and adds a value of "headline" to their class attributes
    - The second line selects the first 3 list items and hides the elements, the reason why it hides them because if they are shown then how can they fade in, so after hiding them the elements are faded into view to give an animation of fading elements from unseen to seen
    - Notice the selector ~:lt(3)~, this is a jQuery specific selector, it stands for "less than" and it uses a zero-based indexing, so it filters the selection to items with an index less than 3, so the first list item is index 0 and the next is index 2 and so on, so ~lt(3)~ wants to get only the list items that have an index "less than" 3
    - The last line of the code set an event listener on each ~<li>~ element and when the user clicks on one then it triggers an anonymous function
    - Inside this anonymous we can have ~element.target~ to get the target element or ~this~ (only if the event handler was added directly to the target element) so we use ~this~ with ~$()~ and whenever you give a DOM element to the function ~jQuery()~ or ~$()~ then you are basically wrapping the DOM element in a jQuery object giving you access to all of jQuery's powerful methods
    - So the last line of code, we add an event handler, inside the anonymous function we get the target element using ~this~, we wrap it in a jQuery object, and then we finally call ~remove()~ on the object because this jQuery method removes the selected elements from the DOM completely along with all their child elements and associated data and event handlers
    - Thus the last line of code is basically adding an event listener so when a user clicks on a list item it triggers a function that removes the element from the page

** Section 7.3: Why Use jQuery?
   - jQuery does not do anything you cannot achieve with pure JS, it is a JS file at the end but it can make coding simpler
   - This is outdated but before selecting the elements you wanted was hard because older browsers did not support the lastest methods for selecting elements and IE did not treat whitespace as text nodes like the other browsers
   - This makes it hard to select the right elements across all major browsers so jQuery instead uses CSS selectors to select elements because CSS selectors are fast at selecting elements, are more accurate about which elements to select, require less code (compared to older DOM methods), and is already used by most front-end developers
   - In addition, jQuery adds extra selectors or extends the set of CSS selectors to offer greater functionality (these extensions are part of jQuery and do not work in CSS) such as ~:contains("text")~ which matches elements that contain the specified text
   - DOM has their own CSS selector functions called ~querySelector()~ and ~querySelectorAll()~ but when they were introduced these methods were not supported by older browsers
   - jQuery has methods that offer web developers simpler ways to perform common tasks such as loop through elements, add or remove elements from the DOM tree, handle events, fade elements into / out of view, and handle ajax requests, thus writing less code to achieve those tasks
   - jQuery also offers chaining of methods, so once you have selected some elements, this allows you to apply multiple methods to the same selection
   - jQuery is cross-browser compatible so instead of writing cross-browser fallback code, jQuery uses feature detection to find the best way to achieve a task by using conditional statements such as if the browser supports this then do this, if not check if it supports this, if not resort to last option (similar to checking if the browser supported methods in the previous chapter)
   - During the time, jQuery was building a lot of code to support IE6, 7, and 8 (older browsers) and starting with jQuery 2.0 support for older browsers would be dropped but a lot of people still used older browsers at the time so the jQuery team decided to maintain two parallel versions of jQuery: jQuery 1.9+ and jQuery 2.0+
   - This book is outdated and we are now in jQuery 3.0+ with no plans to ever release jQuery 4.0

** Section 7.4: Finding Elements
   - With jQuery you select elements using CSS-style selectors but jQuery also offers some extra selectors that are not part of CSS

   - *Basic Selectors:*
   | Selector               | CSS or jQuery                | Description                                                                                                                 |
   |------------------------+------------------------------+-----------------------------------------------------------------------------------------------------------------------------|
   | ~*~                    | CSS                          | Selects all elements                                                                                                        |
   | ~element~              | CSS                          | All elements with that element name                                                                                         |
   | ~#id~                  | CSS                          | Elements whose ~id~ attribute has thevalue specified                                                                        |
   | ~.class~               | CSS                          | Elements whose ~class~ attribute has the value specified                                                                    |
   | ~selector1, selector2~ | CSS                          | Elements that match more than one selector (see also the ~.add()~ method which is more efficient when combining selections) |

   - *Hierarchy Selector*
   | Selector              | CSS or jQuery | Description                                                                                                                                           |
   |-----------------------+---------------+-------------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~ancestor descendant~ | CSS           | An element that is a descendant of another element (e.g. ~li a~)                                                                                      |
   | ~parent > child~      | CSS           | An element that is a direct child of another element (you can use ~*~ in the place of the child to select all child elements of the specified parent) |
   | ~previous + next~     | CSS           | Adjacent sibling selector only selectors elements that are immediately followed by the previous element                                               |
   | ~previous ~ siblings~ | CSS           | Sibling selector will select any elements that are a sibling of the previous element                                                                  |

   - *Basic Filters*
   | Selector         | CSS or jQuery | Description                                                              |
   |------------------+---------------+--------------------------------------------------------------------------|
   | ~:not(selector)~ | CSS           | All elements except the one in the selector (e.g. ~div:not('#summary')~) |
   | ~:first~         | jQuery        | The first element from the selection                                     |
   | ~:last~          | jQuery        | The last element from the selection                                      |
   | ~:even~          | jQuery        | Elements with an even index number in the selection                      |
   | ~:odd~           | jQuery        | Elements with an odd index number in the selection                       |
   | ~:eq(index)~     | jQuery        | Elements with an index number equal to the one in the parameter          |
   | ~:gt(index)~     | jQuery        | Elements with an index number greater than the parameter                 |
   | ~:lt(index)~     | jQuery        | Elements with an index number less than the parameter                    |
   | ~:header~        | jQuery        | All ~<h1> - <h6>~ elements                                               |
   | ~:animated~      | jQuery        | Elements that are currently being animated                               |
   | ~:focus~         | CSS           | The element that currently has focus                                     |

   - *Content Filters*
   | Selector            | CSS or jQuery | Description                                                                                                                                      |
   |---------------------+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~:contains('text')~ | jQuery        | Elements that contain the specified text as a parameter                                                                                          |
   | ~:empty~            | jQuery        | All elements that have no children                                                                                                               |
   | ~:parent~           | jQuery        | All elements that have a child node (can be text or element)                                                                                     |
   | ~:has(selector)~    | jQuery        | Elements that contain at least one element that matches the selector (e.g. ~div:has(p)~ matches all ~div~ elements that contain a ~<p>~ element) |

   - *Visibility Filters*
   | Selector   | CSS or jQuery | Description                                                                                                                                                                                                                          |
   |------------+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | ~:hidden~  | jQuery        | Selects all elements that are hidden                                                                                                                                                                                                 |
   | ~:visible~ | jQuery        | All elements that consume space in the layout of the page, not selected if ~:display:none; height / width: 0;~ or ancestor is hidden and selected if ~visibility: hidden; opacity: 0~ because they would take up space in the layout |

   - *Child Filters*
   | Selector           | CSS or jQuery | Description                                                                          |
   |--------------------+---------------+--------------------------------------------------------------------------------------|
   | ~:nth-child(expr)~ | CSS           | Selects the nth child but it uses a 1-based index                                    |
   | ~:first-child~     | CSS           | Selects the first child from the current selection                                   |
   | ~:last-child~      | CSS           | Selects the last child from the current selection                                    |
   | ~:only-child~      | CSS           | Selects the only child of the element only when there is only a child in the element |

   - *Attribute Filters*
   | Selector                     | CSS or jQuery | Description                                                             |
   |------------------------------+---------------+-------------------------------------------------------------------------|
   | ~[attribute]~                | CSS           | Element that carry the specified attribute (with any value)             |
   | ~[attribute='value']~        | CSS           | Elements that carry the specified attribute with the specified value    |
   | ~[attribute!='value']~       | jQuery        | Elements that carry the specified attribute but not the specified value |
   | ~[attribute^='value']~       | CSS           | The value of the attribute begins with this value                       |
   | ~[attribute$='value']~       | CSS           | The value of the attribute ends with this value                         |
   | ~[attribute*='value']~       | CSS           | The value should appear somewhere in the attribute value                |
   | ~[attribute \vert ='value']~ | CSS           | Equal to given string or starting with string and followed by a hyphen  |
   | ~[attribute~='value']~       | CSS           | The value should be one of the values in a space separated list         |
   | ~[attribute][attribute2]~    | CSS           | Elements that match all of the selectors                                |

   - *Form Selectors*
   | Selector    | CSS or jQuery | Description                                                            |
   |-------------+---------------+------------------------------------------------------------------------|
   | ~:input~    | jQuery        | All input elements                                                     |
   | ~:text~     | jQuery        | All text inputs                                                        |
   | ~:password~ | jQuery        | All password inputs                                                    |
   | ~:radio~    | jQuery        | All radio buttons                                                      |
   | ~:checkbox~ | jQuery        | All checkboxes                                                         |
   | ~:submit~   | jQuery        | All submit buttons                                                     |
   | ~:image~    | jQuery        | All ~<img>~ elements                                                   |
   | ~:reset~    | jQuery        | All reset buttons                                                      |
   | ~:button~   | jQuery        | All ~<button>~ elements                                                |
   | ~:file~     | jQuery        | All file inputs                                                        |
   | ~:selected~ | jQuery        | All selected items from drop-down lists                                |
   | ~:enabled~  | CSS           | All enabled form elements (which is the default for all form elements) |
   | ~:disabled~ | CSS           | All disabled form elements (using the HTML ~disabled~ attribute)       |
   | ~:checked~  | CSS           | All checked radio buttons or checkboxes                                |

   - When you select one or more elements, a jQuery object is returned and it is known as a matched set of a jQuery selection
   - If a selector returns one element, the jQuery object contains a reference to just one element node
   - If a selector returns several elements, the jQuery object contains references to each element
   - Each element is given an index number and the index number starts at zero
     
** Section 7.5: jQuery Methods
   - Once you have made a selection of elements then you can now call methods to do some task on the selected elements
   - You often see jQuery method *names* (not the actual code) written starting with a period (~.~) before the name to highlight that those methods are part of the jQuery object and not JS methods or some other object's methods
   - When you make a selection the jQuery object has a property called ~length~ which will return the number of elements in the object
   - If the jQuery selection did not find any matching elements, you will not get an error by calling any of these methods because they simply won't do or return anything
   - There are also methods that are specifically designed to work with Ajax (which lets you refresh part of the page rather than an entire page)
   - So once we have selected the elements we want (and they are in a jQuery object), the jQuery methods perform tasks on those elements
   - These methods:
     - Get or change content of elements, attributes, and text nodes (content filters)
     - Find and select elements to work with & traverse in the DOM
     - Get or update the dimensions or position of a box (dimension / position)
     - Add effects and animation to parts of the page (effects & animation)
     - Create event listeners for each element in the selection (events)
   - To find all the methods available in jQuery for the latest version, visit: https://api.jquery.com
   - Some jQuery methods both retrieve info from, and update the contents of, elements, but they do not always apply to all elements
   - If a jQuery selection holds more than one element and a method is used to get info from the selected elements, it will retrieve info from only the first element in the matched set
   - For example, let's say we have a list and we select the listed items ~$('li')~ and it returns multiple list items, so when we use the ~.html()~ method to get info from each element, it will return the content of the first element in the matched set
   - To get a different element you can use the methods to traverse or filter the selection or we can write a more specific selector
   - To get the content of all of the elements, one way to do so is by the ~.each()~ method
   - If a jQuery selections holds more than one element and a method is used to update information on the page then it will update all of the elements in the matched set not just the first one
   - When you use the ~.html()~ method to update the elements, it will replace the contents of each element in the matched set
   - To update just one element you can use methods to traverse or filter the selection or write a more specific selector
   - So when a method is used on a selection to get information it will only retrieve info only from the first element but if a method is used on a selection to update info then it will update the info for all elements

** Section 7.6: jQuery Objects
   - When you create a selection with jQuery, it stores a reference to the corresponding nodes in the DOM tree, it does not create copies of them
   - jQuery object is an array-like object because it stores a list of the elements in the same order that they appear in the HTML document (thus preserving the order unlike other objects where the order of the properties is not usually preserved)
   - As you have seen, when HTML pages load, the browser creates a model of the page in memory
   - When you create a jQuery selection, the jQuery object holds references to the already existing elements in the DOM so it does not create a copy of them (it uses the references to the already existing elements in the DOM)
   - When programmers say that a variable or object is storing a reference to something, what it is doing is storing the /location/, a piece of info, in the browser's memory
   - To create a jQuery object it takes time, processing resources, and memory because the interpreter must: find the matching nodes in the DOM tree, create the jQuery object, and store references to the nodes in the jQuery object
   - So if the code needs to use the same selection more than once it is better to use the same jQUery object again rather than repeat the above process
   - To do this, you store a reference to the jQuery object in a variable, thus in a sense you are caching a jQuery object by having a variable store the reference to the jQuery object
   - Note that when a variable contains a jQuery object, it is often given a name beginning with the ~$~ symbol to help differentiate it from other variables in your script
   - Caching jQuery selections is similar to the idea of storing a reference to a DOM node once you have made a DOM query

** Section 7.7: Looping & Chaining
   - In plain JS, if you wanted to do the same thing to several elements, you would need to write code to loop through all of the elements you selected
   - With jQuery when a selector returns multiple elements, you can update all of them using the one method and there is no need to use a loop
   - For example ~$('li.em').addClass('seasonal');~ this method is going to add to the class attribute for all the elements that are found using the selector (doesn't matter if there are one or many)
   - The ability to update all of the elements in the jQuery selection is known as *implicit iteration*
   - When you want to get information from a series of elements you use ~.each()~ method rather than writing a loop (more on it later)
   - If you want to use more than one jQuery method on the same selection of elements, you can list several methods at a time using dot notation to separate each one (for example ~$('li').hide().deplay(500).fadeIn(1400);~)
   - Thus the methods act on the same selection of elements and this process of placing several methods in the same selector is referred to as *chaining*
   - Most methods used to update the jQuery selection can be chained however the methods that retrieve info from the DOM (or about the browser) cannot be chained
   - If one of the method in the chain does not work then the rest will not run either

** Section 7.8: Checking a Page is Ready to Work With
   - jQuery's ~.ready()~ method checks that the page is ready for your code to work with
   - For example, ~$(document).ready(function() {});~ this creates a jQuery object represent the page and when the page is ready, the function inside the parentheses of the ~.ready()~ method is run
   - As with plain JS, if the browser has yet constructed the DOM tree then jQuery will not be able to select elements from it so you either use the ~.ready()~ function or you place the script at the end of the page just before the closing ~</body>~ tag (because that point the elements will have been loaded into the DOM tree)
   - A shortcut for the ready event method on the document object is the following: ~$(function() {});~
   - The shorthand above is more commonly used than ~$(document).ready()~ and benefit of using an anonymous function to contain all of jQuery code is that it creates function-level scope for its variables so it prevents naming collisions with other scripts that might use the same variable names
   - jQuery had a ~.load()~ method as it fired on the ~load~ event but this has been replaced by the ~.on()~ method, recall that the load event fires after the page and all of its resources have loaded so you should use this ~.on()~ method when your script relies on assets to have loaded (e.g. show dimensions of an image)
   - The ~.on()~ method works in all browsers and provides function-level scope for the variables it contains
   - jQuery's ~.ready()~ method checks if the browser supports the ~DOMContentLoaded~ event because it fires as soon as the DOM is loaded and it does not wait for other assets to finish loading making the page appear to load faster
   - jQuery will use an event listener for ~DOMContentLoaded~ if the browser supports it but in older browsers jQuery will wait for the ~load~ event to fire
   - If you were to place the script before the closing body tag then the HTML elements will have been loaded into DOM before your script runs but it is still common for people to use ~.ready()~ because it ensures no matter where the script is placed in the HTML the code will always run when the elements have been successfully loaded into DOM

** Section 7.9: Getting Element Content
   - The ~.html()~ and ~.text()~ methods both retrieve and update the content of elements
   - When ~.html()~ is used to retrieve info from a jQuery selection it retrieves only the HTML inside the first element in the matched set along with any of its descendants (so if the selection has child HTML elements, it will return all the HTML for that selection)
   - When ~.text()~ method is used to retrieve the text from a jQuery selection it returns the content from every element in the jQuery selection, along with the text from any descendants
   - ~.text()~ returns all of the text content of the selected elements as a single string with no HTML tags and no structure it is just concatenated text
   - ~.text()~ returns whitespace characters that are included inside the HTML elements but not the whitespace characters that separate the HTML elements (e.g. ~<li>Test \n New Line</li> <li>Test2</li>~ will return "Test \n New LineTest2" notice how the end of the first list item does not include space to the start of the next list item)
   - To get the content from ~<input>~ or ~<textarea>~ elements use the ~.val()~ method (more about it later)

** Section 7.10: Updating & Inserting Elements

*** Section 7.10.1: Updating Elements
    - There are four methods that update the content of all elements in a jQuery selection:
      - ~.html()~: Gives every elment in the matched set the same new content and the new content may include HTML
      - ~.text()~: Gives every element in the matched set the same new text content and any markup would be shown as text
      - ~.replaceWith()~: Replaces every element in a matched set with new content and it also returns the replaced elements (this method replaces the selected elements entirely with new content, either HTML, a DOM element, or another jQuery element and inserts the new content in their place keeping the same position in the DOM)
      - ~.remove()~: Removes all of the elements in the matched set
       
    - When the ~.html()~ and ~.text()~ methods are used as setters (to update content) they will replace the content of each element in the matched set along with any content and child elements
    - The ~.replaceWith()~ and ~.remove()~ methods replace and remove the elements they match as well as their content and any child elements
    - The ~.html()~ and ~.replaceWith()~ methods can take a string as a parameter and the string can be stored in a variable and contain markup while ~.text()~ also takes a string as a parameter but the markup would be treated as text
    - ~.remove()~ only has 1 optional parameter and that is a selector to filter which matched elements to remove
    - When you add markup to the DOM, be sure to escape all untrusted content properly on the server because both ~.html()~ and ~.replaceWith()~ methods carry the same security risks as using the DOM's ~innerHTML~ property
    - If you want to use and amend the content of the current selection, these methods can take a function as a parameter and then this function can be used to create new content
    - For example, if you want the existing html to be inside ~<em>~ tags so you take a function as an argument and in that function you return a new string with ~<em>~ tags but inside those tags will have the text of the element
    - To access the current element's properties and methods, you use ~$(this)~ and thus you can get the HTML or text by running ~$(this).text()~ or ~$(this).html()~ and place it in-between the ~<em>~ tags and return the string
    - So return indicates that the content should be returned by the function and replace the html, replace with, or replace the text and this refers to the current element so ~$(this)~ places that element in a new jQuery object so that you can use jQuery methods on it
    - Thus when updating the content of an element you can use a string, a variable, or a function

*** Section 7.10.2: Inserting Elements
    - Inserting new elements involves two steps:
      1. Create the new elements in a jQuery object
      2. Use a method to insert the content into the page
    - To create a new jQuery object you simply pass a string with markup into the ~jQuery()~ function
    - For example, ~$('<li>')~ creates an empty ~<li>~ element and stores it in a jQuery object
    - Another example, ~$('<li class="new">item</li>')~, this creates a jQuery object with a ~<li>~ element that has a class attribute and some text
    - Once you have a variable holding the new content, you can use the following methods to add the content to the DOM tree:
      - ~.before()~: Inserts content before the selected elements
      - ~.after()~: Inserts content after the selected elements
      - ~.prepend()~: Inserts content inside the selected elements after the opening tag
      - ~.append()~: Inserts content inside the selected elements before the closing tag
      - ~.prependTo()~: Inserts the selected elements inside the argument element after the opening tag
      - ~.appendTo()~: Inserts the selected elements inside the argument element after the closing tag
    - Thus you can create new jQuery objects to hold text and markup and then you can add the object to the DOM tree
    - If you create a selection that returns multiple elements then the methods above (~before()~, ~after()~, etc.) will add the same content to each of the elements in the matched set
    - When adding content to the DOM, make sure you have escaped all untrusted content properly on the server
      
** Section 7.11: Getting & Setting Attribute Values
   - You can create attributes or access and update their contents using the following four methods
     - ~.attr()~: This method can get or set a specified attribute and its value, to get the value of an attribute, you specify the name of the attribute as the argument (e.g. ~$('li').attr('id')~) and to update the value of an attribute you specify both the attribute name and its new value (e.g. ~$('li').attr('id', 'new-id')~)
     - ~.removeAttr()~: This method removes a specified attribute and its value, you specify the name of the attribute as an argument (e.g. ~$('li').removeAttr('id')~)
     - ~.addClass()~: This methods adds a new value to the existing value of the class attribute and it does not overwrite existing values
     - ~.removeClass()~: This method removes a value from the class attribute leaving any other class names within that attribute intact
   - You can work with any attribute on any element using ~attr()~ and ~removeAttr()~ methods
   - If you use the ~attr()~ method to update an attribute that does not exist then it will create the attribute and give it the specified value
   - The value of the ~class~ attribute can hold more than one class name each separated by a space
   - The ~addClass()~ and ~removeClass()~ methods are powerful because they let you add or remove an individual class name within the value of the class attribute and they do not affect any other class names

** Section 7.12: Getting & Setting CSS Properties
   - The ~.css()~ method lets you retrieve and set the values of CSS properties
   - To get the value of a CSS property, you indicate which property you want to retrieve in parentheses (e.g. ~$('li').css('background-color');~) and if the matched set contains more than element it will return the value from the first element
   - To set the values of a CSS property, you specify the property name as the first argument in the parentheses then a comma, followed by its value as the second argument (e.g. ~$(li).css('background-color', '#272727');~), this will update every element in the matched set
   - You can also specify multiple properties in the same method using object literal notation where properties and values are placed in curly braces, a colon is used to separate property names from their values, and a comma separates each pair (but there is not one after the last pair)
   - For example,
     
   #+BEGIN_SRC javascript
     $('li').css({
	 'background-color': '#272727',
	 'font-family': 'Courier'
     });
   #+END_SRC

   - When dealing with dimensions that are specified in pixels, you can increase and decreases the values using the ~+=~ and ~-=~ operators (e.g. ~$('li').css('padding-left', '+=20')~)
   - Note that it is better to change the value of a class attribute to trigger new CSS rules in the style sheet rather than to change CSS properties from within the JS file itself

** Section 7.13: Working with Every Element in a Selection
   - jQuery allows you to recreate the functionality of a loop on a selection of elements using the ~.each()~ method
   - Although there are many jQuery methods that update all of the elements in a matched set without the need for a loop, however, there are times when you want to loop through each of the elements in the section often because you are trying to get info from each element in the matched set or you want to perform a series of actions on each of the elements
   - The ~.each()~ method is provided for this purpose and the parameter of the ~.each()~ method is a function (an anonymous function or a named function)
   - ~.each()~ allows you to perform one or more statements on each of the items in the selection of elements that is returned by a selector
   - ~.each()~ takes one argument: a function containing the statements you want to run on each element (e.g. ~$('li').each(function() {})~
   - You first get the matched set by using ~$()~, you then call ~.each()~ to apply the same code to each element in the selection, and then the function is run for each of the items in the list
   - As the ~.each()~ method goes through the elements in a selection, you can access the current element using the ~this~ keyword and you will often see ~$(this)~ which uses the ~this~ keyword to create a new jQuery selection containing the current element allowing you to use jQuery methods on the current element
   - Note that you can access the current element using the keyword ~this~ and if you need to access properties of the node then it is better to use plain JS (more efficient) but if you need to use jQuery methods then that is when you create a jQuery object (~$(this)~)
   - Finally, ~.each()~ accepts a parameter, this parameter wil indicate the index of the element in the set, the matched set will be a zero-based index and thus it will start at 0 and go from there
     
** Section 7.14: Event Methods, Event Object, & Event Handlers
   - The ~.on()~ method is used to handle all events but behind the scenes jQuery handles all of the cross-browser issues seen in the previous chapter
   - Using the ~.on()~ method is no different than using any other jQuery method: you use a selector to create a jQuery selection and then you use the ~.on()~ to indicate which event you want to respond to and the function then adds an event listener to each element in the selection
   - ~.on()~ was introdcued in v1.7 of jQuery and prior to that jQuery would use separate methods for each event, e.g. ~.click()~, ~.focus()~, etc. but now ~.on()~ is only used
   - For example,

   #+BEGIN_SRC javascript
     $('li').on('click', function() {
	 $(this).addClass('complete');
     });
   #+END_SRC

   - In the example, we first get the selected items or matched set and then using the ~.on()~ method we specify, in the first argument, the event we want to respond to and the second argument we have the code we want to run when the event occurs on any element in the matched set
   - The function in the second argument can be a named function or an anonymous function
   - Almost all browsers events work with ~.on()~ and jQuery even has their own custom-built events like ~ready~ which is not a native DOM event but is a jQuery event that fires whenever the page is ready and ready to be worked with
   - You may be able to also specify multiple events in the 1st parameter which will fire the same function, you specify the events in the 1st parameter separated by a space in between them

   - Every event handling functions receives an ~event~ object and it has methods and properties to the event that occured
   - Just like the JS event object, the jQuery event object has properties and methods that tell you more about the event that took place
   - If you look at the function that is called when the event occurs, the event object is named in parentheses and this named is used within the function to refer the event object
   - For example,
     
   #+BEGIN_SRC javascript
     $('li').on('click', function(e) {
	 eventType = e.Type;
     });
   #+END_SRC

   - In the example above, we gave the event object a parameter name, we then use that name in the function to reference the event object, and then we can access the properties and methods of the object using the familiar dot notation (member operator)
   - Some properties include ~type~ (type of event, e.g. click, mouseover, etc.), ~which~ (button or key that was pressed), ~data~ (object literal containing extra info passed to the function), and more
   - Some methods include ~.preventDefault()~ and ~.stopPropagation()~, and more

   - The ~.on()~ method has two optional properties that let you: (1) filter the matched set to only respond to events that happend on a set of elements and (2) pass extra info into the event handler using object literal notation
   - The actual syntax of the ~.on()~ method is as follows:

   #+BEGIN_SRC javascript
     .on(events [, selector] [, data], function(e));
   #+END_SRC

   - The first argument is the event you want to respond to and if you want to respond to more than one event then you can provide a space-separated list of event names (e.g. 'focus click')
   - The second argument is optional and this allows you to further filter the matched set to only respond to the event happening on a subset of the initial jQuery selection, this was great for event delegation because now you can filter its descendants as well and event handlers would be for the ancestor but listen on its descendants thus having event delegation
   - The third argument is also optional and you can pass extra info to the function that is called when the event is triggered and the info is passed along with the event object
   - So the third argument takes in an object literal and you can access that info via the event object (~e.data~) and access the properties in the object literal by using the dot operator and using the same name in ~e.data~ as in the object literal
   - The fourth argument is the function that should be run when the specified events occur on one of the elements in the matched set (or filtered matched set)
   - And finally, the event object is automatically passed to the function but in order to use it you must give the function a parameter name for the event object
   - Before jQuery v1.7 the ~.delegate()~ function would be used to add event handlers for the parent and listen to the events on the child but was replaced since v1.7+ with ~.on()~

** Section 7.15: Animation
   - When you start using jQuery, the effects methods can enhance your web page with transitions and movement
   - With jQuery you can make content animate fading in and out, slide them up and down, or hide them or show them
   - When an element that was previously hidden is shown, faded in, or slides into view, the other elements on the page may move to make space for it
   - When an element is hidden, has been faded out, or has slid out of view, the other elements on the page can move into the space these elements took up
   - Methods with ~toggle~ in their name will look at the current state of the element (whether it is visible or hidden) and will switch to the opposite state
   - However, most of these animations can be done in CSS and it best to use CSS for animations because it is faster than jQuery

   | Method           | Description                                                                                             |
   |------------------+---------------------------------------------------------------------------------------------------------|
   | ~.show()~        | Displays selected elements                                                                              |
   | ~.hide()~        | Hides selected elements                                                                                 |
   | ~.toggle()~      | Toggles between showing and hiding selected elements                                                    |
   | ~.fadeIn()~      | Fades in selected elements making them opaque                                                           |
   | ~.fadeOut()~     | Fades out selected elements making them transparent                                                     |
   | ~.fadeTo()~      | Changes opacity of selected elements                                                                    |
   | ~.fadeToggle()~  | Hides or shows selected elements by changing their opacity (the opposite of their current state)        |
   | ~.slideUp()~     | Hides selected elements with a sliding motion                                                           |
   | ~.slideDown()~   | Shows selected elements with a sliding motion                                                           |
   | ~.slideToggle()~ | Hides or shows selected elements with a sliding motion (in the opposite direction to its current state) |
   | ~.delay()~       | Delays execution of subsequent items in queue                                                           |
   | ~.stop()~        | Stops an animation if it is currently running                                                           |
   | ~.animate()~     | Creates custom animations                                                                               |

   - The ~.animate()~ method allows you to create some of your own effects and animations by changing CSS properties
   - You can animate any CSS property whose value can be represented as a number (e.g. height, width, font-size, etc.) but not those whose value would be a string (e.g. font-family, text-transform, etc.)
   - CSS properties inside the method is written using camelCase notation so the first word is all lowercase and each subsequent word starts with an uppercase character (e.g. ~border-top-left-radius~ would become ~borderTopLeftRadius~)
   - The ~.animate()~ function accepts 4 arguments, the first argument is the object literal and then 3 optional arguments
   - The CSS properties are specified in the object literal (e.g. ~{opacity: 0.0}~)
   - After the second argument is optional and it is the speed parameter which indicates the duration of the animation in milliseconds (it can also take the keywords "slow" and "fast")
   - The third argument is optional and it is the easing parameter, it can have two values: "linear" (the speed of animation is uniform) or "swing" (speeds up in the middle of the transition and is slower at the start and end) and if no value is specified then "swing" is used by default
   - The fourth argument is optional and it is called complete, it is used to call a function that should run when the animation has finished, this is known as a callback function, so it can be a named function or an anonymous function
   - For example,

   #+BEGIN_SRC javascript
     $('li').on('click', function(){ // add event handler when list item is clicked
	 $(this).animate({ // animate list item
	     opacity: 0.0, // make it disappear
	     paddingLeft: '+=80' // make it move to right like if it is leaving
	 }, 500, 'swing', function(){ // when animation finished actually remove the list item from DOM
	     $(this).remove();    
	 });
     });
   #+END_SRC

   - To animate between two colors, rather than using ~.animate()~ method you can instead use the jQuery's jQuery-color plugin

** Section 7.16: Traversing the DOM
   - When you have made a jQuery selection, you can use these methods to access other element nodes relative to the initial selection

   | Method         | Selector | Description                                               |
   |----------------+----------+-----------------------------------------------------------|
   | ~.find(<>)~    | Required | All elements within current selection that match selector |
   | ~.closest(<>)~ | Required | Nearest ancestor (not just parent) that matches selector  |
   | ~.parent()~    | Optional | Direct parent of current selection                        |
   | ~.parents()~   | Optional | All parents of current selection                          |
   | ~.children()~  | Optional | All children of current selection                         |
   | ~.siblings()~  | Optional | All siblings of current selection                         |
   | ~.next()~      | Optional | Next sibling of current element                           |
   | ~.nextAll()~   | Optional | All subsequent siblings of current element                |
   | ~.prev()~      | Optional | Previous sibling of current element                       |
   | ~.prevAll()~   | Optional | All previous siblings of current element                  |

   - Each method finds elements that have a different relationship to those that are in the current selection (e.g., parents or children of the current selection)
   - The ~.find()~ and ~.closest()~ methods both require a CSS-style selector as an argument while the other methods the CSS-style selector is optional
   - But if a selector is provided, both the method and selector must match in order for the element to be added to the new selection
   - For example, if you start with a selection that contains one list item, you could create a new selection containing the other items from the list using the ~.siblings()~ method
   - If you added a selector into the method such as this: ~.siblings('.important')~ then it would find only siblings with a class attribute whose value included "important"
   - If the original selection contains multiple elements, these methods all work on all of the elements in the selection (which can result in quite an odd selection of elements) so you may need to narrow down your initial selection before traversing the DOM
   - Behind the scenes, jQuery will handle the cross-browser inconsistencies involved in traversing the DOM 9such as whitespace nodes being added by some browsers)

** Section 7.17: Add & Filtering Elements in a Selection
   - Once you have a jQuery selection, you can add more elements to it or you can filter the selection to work with a subset of the elements

   | Method      | Description                                                                                                     |
   |-------------+-----------------------------------------------------------------------------------------------------------------|
   | ~.add()~    | Adds new content to the items in the existing selection and places the resulting content in a new jQuery object |
   | ~.filter()~ | Finds elements in the matched set that in turn match a second selector                                          |
   | ~.find()~   | Finds descendants of elements in the matched set that match a selector                                          |
   
* Keywords
| Term | Definition |
|------+------------|
|      |            |

* Questions
  - *Q*: How is ~$()~ shorthand for ~jQuery()~?
         - ~$()~ works because ~$~ is an alias for ~jQuery()~
	 - jQuery assigns its main function to ~$~ because ~$~ is a valid variable or function name
	 - For example, somewhere in the code it does the following: ~var $ = jQuery~
	 - Of course it doesn't use the parentheses because it is not invoking it just yet
	 - Thus we do add the parentheses to ~$~ then you get ~$()~ and that is the function being invoked
	 - So if you were to override ~$~ to a different value then ~$()~ would no longer work
	 - In the end, ~$~ is a variable (alias) for the function called ~jQuery~

  - *Q*: Does the ~$().on()~ function accept anonymous functions and named functions?
         - Yes they accept anonymous functions and they also accepted named functions
	 - Both anonymous functions and named functions also accept the event object inside the ~on()~ jQuery method

  - *Q*: What is the difference between ~.filter()~ and ~.find()~?
    
* Summary
