#+title: Chapter 12: Filtering, Searching, & Sorting
#+author: Alfredo Mejia
#+options: num:nil html-postamble:nil
#+html_head: <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css" /> <style>body {margin: 5%} h1,h2,h3,h4,h5,h6 {margin-top: 3%} .content ul:not(:first-child) {margin-top: 0.25em}}</style>

* Navigation
| Nav   | Title                                                       | Links                                   |
|-------+-------------------------------------------------------------+-----------------------------------------|
| Index | Notes Home                                                  | \vert [[file:../../../index.html][html]] \vert [[file:../../../index.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main][github]] \vert |
| Home  | JavaScript & JQuery - Interactive Front-end Web Development | \vert [[file:../000.Home.html][html]] \vert [[file:../000.Home.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development][github]] \vert |
| Prev  | Chapter 11: Content Panels                                  | \vert [[file:../011.Content_Panels/011.000.Notes.html][html]] \vert [[file:../011.Content_Panels/011.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/011.Content_Panels][github]] \vert |
| Next  | Chapter 12: Form Enhancement & Validation                   | \vert [[file:../013.Form_Enhancement_and_Validation/013.000.Notes.html][html]] \vert [[file:../013.Form_Enhancement_and_Validation/013.000.Notes.org][org]] \vert [[https://github.com/alfredo-mejia/notes/tree/main/Web/JavaScript_and_JQuery_Interactive_Frontend_Web_Development/013.Form_Enhancement_and_Validation][github]] \vert |

* Notes

** Section 12.1: Introduction
   - If your pages contain a lot of data, there are 3 techniques that you can use to help your users to find the content they are looking for:
     - *Filtering*: Filtering lets you reduce a set of values by selecting the ones that meet stated criteria
     - *Search*: Search lets you show the items that match one or more words the user specifies
     - *Sorting*: Sorting lets you reorder a set of items on the page based on criteria (e.g. alphabetically)
   - Before dealing with filtering, searching, and sorting, you have to consider how you are going to store the data that you are working with, one option could use arrays to hold data objects (and each object has its own properties / data)

** Section 12.2: JavaScript Array Methods
   - An array is a kind of object and an array has various methods and properties
   - Arrays are often used to store complex data including other objects
   - Each item in an array is sometimes called an element or item (however don't associate the word "element" with the HTML elements, it is something unrelated)
   - Some methods of an array are:
     - ~push()~: adds one or more items to the end of the array and returns the number of items in it
     - ~unshift()~: adds one or more items to the start of the array and returns new length of it
     - ~pop()~: removes last element from array and returns the element
     - ~shift()~: removes first element from array and returns the element
     - ~forEach()~: executes a function once for each element in array
     - ~some()~: checks if some elements in array pass a test specified by a function
     - ~every()~: checks if all elements in array pass a test specified by a function
     - ~concat()~: creates new array containing this array and other array / values
     - ~filter()~: creates new array with elements that pass a test specified by a function
     - ~sort()~: reorders items in array using a function (called a compare function)
     - ~reverse()~: reverses order of items in array
     - ~map()~: calls a function on each element in array & creates a new array with results

*** Section 12.2.1: Filtering
    - Filtering lets you reduce a set of values
    - Filtering allows you to create a subset of data that meets certain criteria
    - The array object has two methods that are very useful for filtering data (~forEach()~ and ~filter()~) and as they filter the data, the items that pass a test are added to a new array
    - The ~forEach()~ method loops through the array and applies the same function to every item in it
    - ~forEach()~ is very flexible because the function can perform any kind of processing with the items in an array (not just filtering)
    - The anonymous function in the ~forEach()~ acts as a filter because it can check if it satifies the filter criteria or not, and if so, it can add them (the filtered results) to a new array
    - When using ~forEach()~, the named or anonymous function given can have a parameter and this parameter represents the current single item in the array which you can use in your function
    - The ~filter()~ method also accepts a function which is applied to each item in the array but this function only returns ~true~ or ~false~
    - If the ~filter()~ method returns true then the method adds the item to a new array, otherwise it is not added to the new array
    - The ~filter()~ syntax is slightly simpler than ~forEach()~ but it is only meant to be used to filter data
    - The function inside ~filter()~ also accepts a parameter and that parameter represents the current item in the iteration
    - If you let users filter the contents of a page, you can build all of the HTML content and then show and hide the relevant parts as the user interacts with the filters
    - So instead of creating HTML elements that fit the criteria of the filters instead you create the HTML elements for all items in the array and show or hide items as the filters are inputted and processed (thus you do not need to delete or create HTML elements but simply show or hide them and thus take less resources)
    - To filter elements that are "not so easy to filter" like images, you use something called ~data-tags~
    - These tags are stored as a HTML attribute on each of the ~<img>~ elements since HTML5 allows you to store any data with an any element using an attribute that starts with the word ~data-~
    - The values of the ~data-tags~ are comma-separated (technically in JS, it is one big value but with commas you can split the string more easily) , for example, I could have data tag like ~data-color="green, purple, orange"~
    - So the images can have multiple values inside their data tag and then you can filter the image elements based on the value of their data tags
      
** Section 12.3: jQuery Collections
   - jQuery collections are array-like objects representing DOM elements
   - jQuery has similar methods to an array for modifying the elements
   - After calling the jQuery collections methods, you can use or chain other jQuery methods on the selection returned from the collection methods
   - jQuery Collections methods are:
     - ~.add()~: adds elements to a set of matched elements
     - ~.not()~: removes elements from a set of matched elements
     - ~.each()~: applies same function to each element in a matched set
     - ~.filter()~: reduces number of elements in a matched set to those that either match a selector or pass a test specified by a function
     - ~.toArray()~: converts a jQuery collection to an array of DOM elements, so now it becomes an array of objects and you can use the methods shown above

** Section 12.4: ECMAScript
   - ECMAScript is the specifications that JavaScript is based upon
   - EMCAScript is the official name for standardized version of JS, EMCAScript is not JS, EMCAScript is the specifications and JS is the implementation of that specification
   - ECMA International is the standard body that looks after the language and discuss any new features and browser manufacturers often add features beyond the ECMA specs (typically agreed upon in WHATWG, W3C, or individual vendors)
   - This is why some older browsers may not support the latest features (and only work with newer / modern browsers)
   - There is a script to help with older browsers not supporting new features and it can be found here: https://github.com/es-shims/es6-shim
   - This script reproduces their functionality for legacy browsers

** Section 12.5: Arrays vs Objects
   - In order to represent complex data you might need several objects
   - Groups of objects can be stored in arrays or as properties of other objects so when deciding which approach to use, consider how you will use the data
   - Arrays:
     - When the order of the objects is important, they should be stored in an array because each item in an array is given an index number (key-value pairs in objects are not ordered)
     - Note that the index number can change if objects are added / removed
     - Arrays also have properties and methods that help when working with a sequence of items (e.g. ~sort()~ method reorders items in an array and ~length~ property counts the number of items)
     - To retrieve data from an array of objects, you can use the index number for the object
     - To add / remove objects in an array, you can use array methods
     - To iterate over the items in an array you can use ~forEach()~
   - Objects:
     - When you want to access objects using their name, they work well as properties of another object (because you would not need to iterate through all objects to find that object as you would in an array)
     - But note that each property must have a unique name (e.g. you cannot have two properties called ~Casey~ and ~Camille~ within the same object)
     - To retrieve data from an object stored as a property of another object, you can use the object's name (e.g. ~obj.propertyName~)
     - To remove / delete an object (since it is a property) from another object, you can use the ~delete~ keyword or erase its content with a blank string
     - To iterate over child objects you can use the builtin method ~Object.keys(myObj)~ to retrieve the name of all the properties (children) from the object

** Section 12.6: Search
   - Search is like filtering but you show only results that match a search term
   - In the book example, we have images and each image has some "tags", these tags can be added to the ~alt~ text and the ~alt~ text can be used to search the images
   - So the "live search" works by searching or looking through the ~alt~ text of images and as you type the images are narrowed down to match the search criteria
   - This feature does some NLP technique either an exact match whose ~alt~ text contains the search term or whose ~alt~ text is similar to the search time

** Section 12.7: Sorting
   - Sorting involves taking a set of values and reordering them
   - Computers often need detailed instructions about how to sort data
   - The Array object has the ~sort()~ method and when you sort an array using the ~sort()~ method, you change the order of the items it holds
   - Remember that the elements in an array have an index number, so sorting can be compared to changing the index numbers of the items in the array
   - By default, the ~sort()~ method orders items lexicographically (it is the same order dictionaries use - e.g. [1, 2, 124, 14] --> [1, 124, 14, 2])
   - Lexicographic order is as follows:
     1. Look at the first letter and order words by the first letter (when talking about letters, it can also apply to numbers)
     2. If two words share the same first letter, order those words by the second letter
     3. If two words share the same first two letters, order those words by the third letter, etc.
   - To sort items in a different way, you can write a compare function
     - The compare function compares two values at a time and returns a number
     - The number it returns is then used to rearrange the items in the array
     - The ~sort()~ method only ever compares two values at a time and it determines whether value ~a~ should appear before or after value ~b~
     - Because only two values are compared at a time, the ~sort()~ method may need to compare each value in the array with several other values in the array
     - ~sort()~ can have an anonymous or a named function as a parameter and this function is called a compare function and it lets you create rules to determine whether value ~a~ should come before or after value ~b~
     - A compare function should return a number and that number indicates which of the two items should come first
     - The ~sort()~ method will determine which values it needs to compare to ensure the array is ordered correctly, you just have to write the compare function so that it returns a number that reflects the order in which you want items to appear
     - *Less than zero*: This indicates that it should show ~a~ before ~b~
     - *Equal to zero*: Indicates that the items should remain in the same order
     - *Greater than zero*: Indicates that it should show ~b~ before ~a~

*** Section 12.7.1: How Sorting Works
    - The actual sorting algorithm depends on the browser's implementation (the JS engine)
    - The only thing we have control is the condition of which the sorting algorithm uses to determine if a value comes before or after another value or stays in the same position (since the sorting algorithm compares two values at a time)
    - However, the actual sorting algorithm (how it selects the two values in the array to compare) depends on the browser's implementation
    - The algorithm can vary per browser and per data type of the values in the array, but some algorithms include: QuickSort, Introsort, MergeSort, SelectionSort, AVLSort, and Timsort
    - These algorithms are used to sort the items while using your compare function to compare two values and determine keep the same position or put one value before the other

*** Section 12.7.2: Sorting Dates
    - Dates need to be converted into a ~Date~ object so that they can then be compared using ~<~ and ~>~ operators
    - If the dates are held as strings then the compare function needs to create a ~Date~ object from the string so that the two dates can be compared using the ~<~ and ~>~ operators
    - Once they have been converted into a ~Date~ object, JS stores the date as the number of milliseconds since the 1st January 1970
    - With the date stored as a number, two dates can be compared in the same way that numbers are compared

*** Section 12.7.3: Sorting a Table
    - Each row of the table can be stored in an array
    - When users click on a heading, it triggers an anonymous function to sort the contents of the array which contains the table rows
    - The rows are sorted in ascending / descending order using the data in that column of which the heading was clicked
    - Clicking the same header again will toggle between ascending / descending order based on the column data of which the heading was clicked
    - Each column can contain different types of data compared to other columns
    - The type of data can be specified in the HTML ~<th>~ element using a data tag
    - Each type of data needs a different compare function
    - The comapre function will also only use the column of which it was clicked on, for example, let's say we have a 2D array, or an array of objects, where the object represents the row and the array is the array of rows
    - Whenever we click on a column header, we will use a compare function that only uses the property of the object that corresponds to the column clicked because we are trying to sort based on the column that was clicked and no other column
    - If another column was clicked then we will only use the property since we only want to sort the objects based on that column, the whole array will be sorted by only using certain properties of the object based on the column clicked

** Section 12.8: Chapter Exercise
   - For this chapter exercise, we will get the "Average Interest Rates on U.S Securities" from the U.S Treasury using their API
   - [[https://fiscaldata.treasury.gov/datasets/average-interest-rates-treasury-securities/average-interest-rates-on-u-s-treasury-securities][Here]] is the documentation of the API
   - The data will be shown in a tabluar form
   - Each row will show the average interest rates on a monthly basis on some type of security
   - The average interest rates will be shown on marketable securities such as Treasury Bills, Notes, Bonds, etc. and non-marketable securities such as domestic series, foreign series, etc.
   - Each row will have a record date, a security type description (marketable vs. non-marketable), a security description (treasury bils, bonds, domestic series, etc.) and average interest rate amount
   - The table will have filters to filter the rows by either marketable or non-marketable and / or the type of security such as treasury bills, bonds, etc.
   - In addition to the filters, the table will be able sort the rows by date (record date), alphabetically (for the securities), and numerically (for the interest rates)
   - Finally, the user would be able to search for a specific security, date, or interest rate
   - The filters, sorting, and searching mechanisms can be used all together, separately or a combination of each
   - [[file:./012.009.Chapter_Exercise/index.html][Here]] is the web app created for this chapter exercise

*** Section 12.8.1: Completing Chapter Exercise (!UPDATE!)
    - After completing the chapter exericse I realized that a "small" chapter exercise can have a lot of features to it
    - I wanted to implement sorting, filters, visibility, and table navigation buttons
    - Each button needs their own event listeners and be able to manage state
    - For example, whenever you add or remove a filter the number of rows change
    - At first I was trying to take my time and add comments and test cases but I soon realized it was taking much longer than expected
    - So I rushed the project and there may be some small bugs from edge cases but for the most part I think the small web app works well
    - The code can definitely be improved but I learned a lot while building this website
    - I used a lot of skills learned from the HTML book and this book as well

** Section 12.9: Summary
   - Arrays are commonly used to store a set of objects
   - Arrays have helpful methods that allow you to add, remove, filter, and sort the items they contain
   - Filtering lets you remove items and only show a subset of them based on a selected criteria
   - Filters often rely on custom functions to check whether items match your criteria
   - Search lets you filter based upon data the user enters
   - Sorting allows you to reorder the items in an array
   - If you want to control the order in which items are sorted, you can use a compare function
   - To support older browsers, you can use a shim script (a script that has the new JS features that have not been or will not be implemented in older browsers but modern browsers have improved at supporting modern web standards)
   
* Keywords
| Term      | Definition                                                                                                  |
|-----------+-------------------------------------------------------------------------------------------------------------|
| Sorting   | The process of arranging items in a specific order                                                          |
| Filtering | The process of selectively extracting or hiding specific data from a larger set based on a certain criteria |

* Questions
  - *Q*: What are HTML data tags?
         - Data tags are custom and arbitrary attributes that can be directly embeded into HTML elements
	 - For example: ~<h1 data-custom-name="value"></element>~
	 - All custom data attributes must begin with the ~data-~ prefix (this ensures they do not conflict with any standard HTML attributes)
	 - Following the ~data-~ prefix, you can use any valid custom name, often using hyphens to separate words
	 - The attribute can hold any string value
	 - Then using JS, you can access ~data-*~ attributes using the ~dataset~ property of an HTML element, which provides a convenient way to work with these attributes in a camelCase format
	 - Data tags allow for custom attributes in HTML elements

  - *Q*: What is sorting by lexicographically?
         - Sorting lexicographically (lexical order or dictionary order) involves arranging elements (strings, words, or sequences of numbers) based on character by character comparison similar to how words are ordered in a dictionary
	 - Elements are compared from left to right, character by character, at corresponding positions
	 - Example sorting: [1, 2, 10] -> [1, 10, 2]

  - *Q*: How does QickSort work?
         - You have an array
	 1. Choose a pivot by selecting an element from the array as the pivot (first, last, random, middle, etc.)
	 2. Rearrange the array so that all elements smaller than the pivot are to its left and all elements greater than the pivot are to its right (one iteration is complete)
	 3. Recursively sort the subarrays applying the same process to the subarray left of the pivot and the subarray to the right of the pivot
	 4. The recursion stops when the subarray has zero or one element

  - *Q*: How does Introsort work?
         - Introsort begins with quicksort and if the recursion depth goes more than a particular limit it switches to Heapsort
	 - If the number of elements is small then it switches to insertion sort
	 - The way it works is that it starts with QuickSort
	 - So it chooses a pivot and partitions the array around the pivot
	 - QuickSort continues and Introsort monitors how deep the recursion goes
	 - Introsort has a maximum recursion depth, if the recursion exceeds this threshold then Introsort switches from QuickSort to HeapSort
	 - Introsort also checks the size of the partitions if the size of the subarray becomes sufficiently small then it switches to Insertion Sort

  - *Q*: How does MergeSort work?
         - Merge sort works by recursively dividing a list into smaller sublists until each sublist contains only one element and then merging these sorted sublists back together in order
	 - It is a divide and conquer algorithm where the "divide" step splits the list and the "conquer" step merges the sorted sublists back together
	 - Here are the steps:
	 1. Divide the input list into two halves until each sublist contains only a single element as a single-element list is considered sorted
	 2. Once the list is fully divided, two sorted sublists are merged into a single sorted list and to merge two sublists you compare the first element of each list and add the smaller one to the new, merged list
	 3. This process repeats, taking the smaller element from the front of the two sublists and adding it to the merged list until all elements from both sublists are included and this merge-and-sort process continues combining the sorted sublists at each level until the entire list is merged back into a single fully sorted list

  - *Q*: How does SelectionSort work?
         - SelectionSort sorts an array by repeatedly selecting the smallest (or largest) element from the unsorted portion of the array and swapping it with the first unsorted element
	 1. Find the smallest element in the array and swap it with the first element (the array is now divided into two parts, the sorted part and the unsorted section, the first element is considered the sorted part)
	 2. Then we continue to the second element (or the first element of the unsorted part of the array) and we find the smallest element among the remaining elements in the unsorted part and swap it with the second element (now the first two elements are sorted and the rest are unsorted)
	 3. We continue to the third element (or the first element of the unsorted part of the array) and we repeat the process until we have sorted the entire array (or moved all the way to the end of the array)

  - *Q*: How does AVLSort work?
         - The first step is to build a AVL tree
	 - AVL tree is a self-balancing BST tree
	 - So you select an element in the array and add it to the BST tree
	 - Remember the BST tree properties:
	   - All nodes in the left subtree of a node contains values strictly less than the node's value
	   - All nodes in the right subtree of a node contains values strictly greater than the node's value
	 - After any insertion or deletion, the AVL tree checks if the balance factor (the difference in height between the left and right subtrees) of any node is greater than 1 or less than -1 and if it is then the tree performs rotations (single or double) to rebalance itself ensuring the AVL property is maintained
	 - Once the AVL tree is constructed and balanced, an in-order traversal is performed to retrieve the elements in sorted order
	 - The nodes are visited by left, root, right and thus the elements are retrieved in ascending order
	   	   
  - *Q*: How does Timsort work?
         - Timesort works by combining the best of merge sort and insertion sort
	 1. Identify runs
	    - Timesort begins by dividing the array into runs - subarrays that are either already sorted or will be made sorted by insertion sort
	    - A run is a consecutive sequence of elements that are either strictly increasing or strictly decreasing
	    - If the run is decreasing, Timesort will reverse it to make it increasing
	    - The idea is to identify chunks of data that are already ordered or nearly ordered since sorting these smaller chunks will be faster than sorting the entire array in one go
	 2. Use Insertion Sort on Small Runs
	    - Timesort uses a fixed minimum run size (typically 32 elements) and if a run is smaller than this threshold, Timesort will extend it by using insertion sort with the following elements
	    - Since timesort analyze elements one-by-one from left to right (for runs), if it sees that the run (runs are ordered elements so the min is always two elements since that can always be considered asc or desc) is small it continues until it reaches the run size and then sorts the selected elements using insertion sort
	 3. Merge Runs using Merge Sort
	    - After the initial runs are created and small runs are sorted , Timesort proceeds by merging the runs into larger sorted subarrays using a merge sort approach
	    - The sorted runs are merged together iteratively until the entire array is sorted using merge sort

* Summary
  - To find content you can either filter, search, or sort
  - To store the data you can use data objects, arrays, or both
  - JavaScript arrays has various methods that can affect the array
  - One of the methods is ~filter()~ which allows you to reduce a set of values by creating a subset of data that meets certain criteria
  - You create the criteria by passing an anonymous function to ~filter()~ which is applied to each item in the array but this function only returns ~true~ or ~false~
  - If the filter method returns treu then the method adds the item to a new array, otherwise it is not added to the new array
  - To filter elements that are "not so easy to filter" like images, you can use something called ~data-tags~
  - ~data-tags~ are stored as HTML attributes on the HTML elements
  - ~data-tags~ are custom and aribitrary attributes that can be directly embedded into HTML and then using JS you can access ~data-*~ attributes using the ~dataset~ property of an HTML element
  - jQuery collections are array-like objects representing DOM elements and jQuery has similar methods to an array for modifying the elements and after calling the jQuery collection methods you can use or chain other jQuery methods on the selection returned from the collection methods
  - EMCAScript is the official name for the standardized version of JS, EMCAScript is not JS, EMCAScript is the specifications and JS is the implementation of that specification
  - EMCA International is the standard body that looks after the language and discuss with any new features and browser manufacturers often add features beyond the ECMA specs (typically agreed upon in WHATWG, W3C, or individual vendors)
  - There is a script called es6-shim that helps produce new features in legacy browsers (but not very relevant in today's age)
  - Groups of objects can be stored in arrays or as properties of other objects so when deciding which approach to use, consider how you will use the data
  - Arrays are good when order is important, arrays are easy to retrieve using indices, and easy to iterate
  - Objects are good when you need to access data by name, remove or delete other objects, and iterate over child objects
  - Search is like filtering but you show only results that match a search term
  - Sorting involves taking a set of values and reordering them and computers often need detailed instructions about how to sort data
  - You can use the array method ~sort()~ which order items lexicographically or you can create your own sort function
  - The ~sort()~ method can also take a function argument, this argument is a function that determines the order of the elements, the function must have two parameters (to compare both elements) and must return a neg value when a should come before b, a pos value when b should come before a, or 0 when both are equal
  - Depending on the function, it creates a new rule for the sorting method to follow
  - My chapter exercise was getting data from the U.S. Treasury Fiscal Data and I was able to use their API for the Average Interest Rates on U.S. Treasury Securities
  - The data was placed into a table and the table had buttons to filter based on user input and sort based on data fields to filter and sort rows
  - The table was also able to hide or unhide columns
  - So sorting is a process of arranging items in a specific order while filtering is the process of selectively extracting or hiding specific data from a larger set based on a certain criteria
  - Lexicographically sorting involves arranging elements based on character by character comparison similar to how words are ordered in a dictionary so ~[1, 2, 13]~ becomes ~[1, 13, 2]~
  - There are many sorting algorithms such as QuickSort, IntroSort, MergeSort, InsertionSort, SelectionSort, AVLSort, TimeSort, and more
