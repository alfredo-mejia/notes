import { isEmptyString, extractLowercaseString } from "./utils.js";
import {Field, IntegerField} from "./Field.js";
import FieldRegistry from "./FieldRegistry.js";

/**
 * Class for building and executing API requests.
 * It provides methods to set the URL, format the results (json, csv, or XML), page size, page number, filters, sorting, and debug mode.
 * It also provides methods to fetch data, build the URL, get the URL, get the format, and more.
 * This is a simple and raw class. It does the primitive HTTP calls and does not do any business logic.
 * It is meant to be used as a base class for other classes that need to build and execute API requests.
 * It is not meant to be used directly.
 * This returns raw data from the API. It does not parse the data into a more usable format.
 * @class
 */
class APIClient {
    #URL;
    #defaultFormat;
    #defaultPageSize;
    #currentPageNumber;
    #pageSize;
    #filters;
    #sorting;
    #debugMode;

    /**
     * Constructor for APIClient.
     * We store the base URL
     * We select "json" as the default format, set the page size to 50, set the current page number to 1, and initialize the filters and sorting arrays.
     * @param {boolean} debugMode - Flag to enable debug logging.
     */
    constructor(debugMode = false) {
        this.#URL = "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/avg_interest_rates";
        this.#defaultFormat = "json";
        this.#defaultPageSize = 50;

        this.#currentPageNumber = 1;
        this.#pageSize = this.#defaultPageSize;
        this.#filters = new Map();
        this.#sorting = new Map();

        this.#debugMode = debugMode;
    }

    /**
     * Function calls the URL and returns the JSON data.
     * This function is straightforward, it makes a request and returns the JSON data: nothing more.
     * The URL is generated by another function.
     * @returns {Promise<JSON>}
     */
    async fetchData() {
        let url = this.#buildURL();
        let response = await fetch(url);

        if (!response.ok) {
            throw new Error(`Error Fetching URL: ${url}\nStatus: ${response.status}\nMessage: ${response.statusText}`);
        }

        return await response.json();
    }

    /**
     * Function builds the URL based on the current state of the class.
     * It uses the URL, format, page size, page number, filters, and sorting to build the URL.
     * This function is straightforward, it builds the URL: nothing more.
     * It calls other functions to get the state of the class and use it to build the URL.
     * @returns {string}
     */
    #buildURL() {
        const params = new URLSearchParams();
        params.append("format", this.getFormat());
        params.append("page[size]", this.getPageSize().toString());
        params.append("page[number]", this.getPageNumber().toString());

        const filters = this.getFilters();
        const sorting = this.getSorting();

        if (!isEmptyString(filters)) {
            params.append("filter", filters);
        }

        if (!isEmptyString(sorting)) {
            params.append("sort", sorting);
        }

        const builderURL = `${this.#URL}?${params.toString()}`;

        if (this.#debugMode) {
            console.log(builderURL);
        }

        return builderURL;
    }

    /**
     * Function returns the URL based on the current state of the class.
     * @returns {string}
     */
    getURL() {
        return this.#buildURL();
    }

    /**
     * Function returns the format based on the current state of the class (default value, no customization yet).
     * @returns {string}
     */
    getFormat() {
        return this.#defaultFormat;
    }

    /**
     * Functions joins all the filters of the class into a single string and returns it
     * @returns {string}
     */
    getFilters() {
        let filters = [];

        for (const [fieldName, fieldNameMap] of this.#filters) {
            for (const [operator, value] of fieldNameMap) {
                filters.push(`${fieldName}:${operator}:${value}`);
            }
        }
        return filters.join(",");
    }

    /**
     * Functions joins all the sorting of the class into a single string and returns it
     * @returns {string}
     */
    getSorting() {
        let sorting = [];
        for (const [fieldName, order] of this.#sorting) {
            if (order === "asc") {
                sorting.push(`${fieldName}`);
            }
            else {
                sorting.push(`-${fieldName}`);
            }
        }
        return sorting.join(",");
    }

    /**
     * Function returns the page size based on the current state of the class.
     * @returns {number}
     */
    getPageSize() {
        return this.#pageSize;
    }

    /**
     * Function returns the page number based on the current state of the class.
     * @returns {number}
     */
    getPageNumber() {
        return this.#currentPageNumber;
    }

    /**
     * Function sets the page size based on the input parameter.
     * The instance is returned so it can be chained with other methods.
     * @param {number} pageSize
     * @returns {APIClient}
     */
    setPageSize(pageSize) {
        if (!Number.isInteger(pageSize) || pageSize <= 0) {
            throw new Error("Page size must be an integer greater than 0.");
        }

        this.#pageSize = pageSize;

        return this;
    }

    /**
     * Function sets the page number based on the input parameter.
     * The instance is returned so it can be chained with other methods.
     * @param {number} pageNumber
     * @returns {APIClient}
     */
    setPageNumber(pageNumber) {
        if (!Number.isInteger(pageNumber) || pageNumber <= 0) {
            throw new Error("Page number must be an integer greater than 0.");
        }

        this.#currentPageNumber = pageNumber;

        return this;
    }

    /**
     * Function adds one to the current page number.
     * So now whenever fetch data is called, it will fetch the next page.
     * The instance is returned so it can be chained with other methods.
     * @returns {APIClient}
     */
    nextPage() {
        this.#currentPageNumber++;

        return this;
    }

    /**
     * Function subtracts one to the current page number.
     * So now whenever fetch data is called, it will fetch the previous page.
     * The instance is returned so it can be chained with other methods.
     * @returns {APIClient}
     */
    previousPage() {
        if (this.#currentPageNumber <= 1) {
            throw new Error("Cannot go back to previous page. Page number is already 1.");
        }

        this.#currentPageNumber--;

        return this;
    }

    /**
     * Function adds a filter to the class.
     * The filter is added to the filter's map.
     * The filter's map is used in another function to be later added to the URL.
     * The filter has the format of: {fieldName}:{operator}:{value} which is constructed in another function.
     * The value is formatted and validated based on the Field.
     * If the value is not valid based on the Field, an error is thrown.
     * If the operator is "in", the value is formatted as a comma-separated list of values.
     * If the operator is "in", the value argument must be an array.
     * The instance is returned so it can be chained with other methods.
     * The filter is added, and if an existing filter exists with the same operator, then the value is replaced.
     * Multiple filters can be for the same field but with different operators.
     * However, only one filter can be for the same field and the same operator.
     * The instance is returned so it can be chained with other methods.
     * @param {Field} field
     * @param {string} operator
     * @param {string | number | Array} value
     * @throws {Error} If the field is not an instance of class Field.
     * @throws {Error} If the field name is invalid.
     * @throws {Error} If the operator is invalid (does not exist).
     * @throws {Error} If the operator is "in" and the value argument is not an array.
     * @throws {Error} If the value is invalid based on the Field isValid() method.
     * @returns {APIClient}
     */
    addFilter(field, operator, value) {
        if (!(field instanceof Field)) {
            throw new Error("Argument Field is not an instance of class Field.");
        }

        let fieldName = extractLowercaseString(field.getName());

        if (isEmptyString(fieldName)) {
            throw new Error("Field name is invalid.");
        }

        // Check if the field name is present
        if (!this.#filters.has(fieldName)) {
            if (this.#debugMode) {
                console.log(`Field name: ${fieldName} not found. Creating new filter.`);
            }

            this.#filters.set(fieldName, new Map());
        }

        // Get field name map
        const fieldNameMap = this.#filters.get(fieldName);

        let operators = FieldRegistry.getFilterOperators();
        operator = extractLowercaseString(operator);

        if (isEmptyString(operator) || !operators.includes(operator)) {
            throw new Error("Operator is invalid.");
        }

        // Format value
        if (operator === "in") {
            if (!Array.isArray(value)) {
                throw new Error("Value is not an array. It needs to be an array with the \"in\" operator.");
            }

            let formattedValues = [];
            for(let i = 0; i < value.length; i++) {
                let formattedValue = field.format(value[i]);
                if (!field.isValid(formattedValue)) {
                    throw new Error("One or more of the values in the array is invalid.");
                }

                formattedValues.push(formattedValue);
            }

            value = `(${formattedValues.map(String).join(",")})`;
        }

        else {
            let formattedValue = field.format(value);
            if (!field.isValid(formattedValue)) {
                throw new Error("Value is invalid.");
            }

            value = formattedValue;
        }

        if (fieldNameMap.has(operator) && this.#debugMode) {
            const oldValue = fieldNameMap.get(operator);
            console.log(`Operator: ${operator} found. Placing old value ${oldValue} with new value ${value}`);
        }
        else {
            console.log(`Operator: ${operator} not found. Adding new operator.`);
        }

        fieldNameMap.set(operator, value);

        return this;
    }

    /**
     * Function adds a sort to the class.
     * The sort is added to the sort's array.
     * The sort's map is used in another function to be later added to the URL.
     * The sort has the format of: {fieldName} or {-fieldName} which is constructed in another function.
     * The order is either "asc" or "desc".
     * If the order is "asc", the sort is added as {fieldName}.
     * If the order is "desc", the sort is added as {-fieldName}.
     * The instance is returned so it can be chained with other methods.
     * If the sort already exists, the sort replaces the old value with the new value.
     * The instance is returned so it can be chained with other methods.
     * @param {Field} field
     * @param {string} order
     * @throws {Error} If the field is not an instance of class Field.
     * @throws {Error} If the field name is invalid.
     * @throws {Error} If the order argument is invalid (can only an option from sort operators usually just "asc" or "desc").
     * @returns {APIClient}
     */
    addSorting(field, order) {
        if (!(field instanceof Field)) {
            throw new Error("Argument Field is not an instance of class Field.");
        }

        let fieldName = extractLowercaseString(field.getName());

        if (isEmptyString(fieldName)) {
            throw new Error("Field name is invalid.");
        }

        let operators = FieldRegistry.getSortOperators();
        order = extractLowercaseString(order);

        if (isEmptyString(order) || !operators.includes(order)) {
            throw new Error("Order operator is invalid.");
        }

        if (this.#sorting.has(fieldName) && this.#debugMode) {
            console.log(`Field name: ${fieldName} already exists in sorting. 
            Replace old value ${this.#sorting.get(fieldName)} with new value ${order}.`);
        }

        if (order === "asc") {
            this.#sorting.set(fieldName, order);
        }

        else {
            this.#sorting.set(fieldName, order);
        }

        return this;
    }

    /**
     * Function deletes the filter array by setting it to an empty array.
     * The instance is returned so it can be chained with other methods.
     * @returns {APIClient}
     */
    clearFilters() {
        this.#filters.clear();

        return this;
    }

    /**
     * Function deletes the sorting array by setting it to an empty array.
     * The instance is returned so it can be chained with other methods.
     * @returns {APIClient}
     */
    clearSorting() {
        this.#sorting.clear();

        return this;
    }

    /**
     * Function resets the class to its initial state.
     * The page number is set to 1.
     * The page size is set to the default page size.
     * The filters are cleared.
     * The sorting is cleared.
     * The instance is returned so it can be chained with other methods.
     * @returns {APIClient}
     */
    reset() {
        this.#currentPageNumber = 1;
        this.#pageSize = this.#defaultPageSize;
        this.clearFilters();
        this.clearSorting();

        return this;
    }
}

export default APIClient;
